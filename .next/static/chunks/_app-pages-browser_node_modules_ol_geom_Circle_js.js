"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_ol_geom_Circle_js"],{

/***/ "(app-pages-browser)/./node_modules/ol/geom/Circle.js":
/*!****************************************!*\
  !*** ./node_modules/ol/geom/Circle.js ***!
  \****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SimpleGeometry.js */ \"(app-pages-browser)/./node_modules/ol/geom/SimpleGeometry.js\");\n/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ \"(app-pages-browser)/./node_modules/ol/extent.js\");\n/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./flat/deflate.js */ \"(app-pages-browser)/./node_modules/ol/geom/flat/deflate.js\");\n/* harmony import */ var _flat_transform_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./flat/transform.js */ \"(app-pages-browser)/./node_modules/ol/geom/flat/transform.js\");\n/**\n * @module ol/geom/Circle\n */\n\n\n\n\n\n/**\n * @classdesc\n * Circle geometry.\n *\n * @api\n */\nclass Circle extends _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  /**\n   * @param {!import(\"../coordinate.js\").Coordinate} center Center.\n   *     For internal use, flat coordinates in combination with `layout` and no\n   *     `radius` are also accepted.\n   * @param {number} [radius] Radius in units of the projection.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   */\n  constructor(center, radius, layout) {\n    super();\n    if (layout !== undefined && radius === undefined) {\n      this.setFlatCoordinates(layout, center);\n    } else {\n      radius = radius ? radius : 0;\n      this.setCenterAndRadius(center, radius, layout);\n    }\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!Circle} Clone.\n   * @api\n   */\n  clone() {\n    const circle = new Circle(\n      this.flatCoordinates.slice(),\n      undefined,\n      this.layout,\n    );\n    circle.applyProperties(this);\n    return circle;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    const flatCoordinates = this.flatCoordinates;\n    const dx = x - flatCoordinates[0];\n    const dy = y - flatCoordinates[1];\n    const squaredDistance = dx * dx + dy * dy;\n    if (squaredDistance < minSquaredDistance) {\n      if (squaredDistance === 0) {\n        for (let i = 0; i < this.stride; ++i) {\n          closestPoint[i] = flatCoordinates[i];\n        }\n      } else {\n        const delta = this.getRadius() / Math.sqrt(squaredDistance);\n        closestPoint[0] = flatCoordinates[0] + delta * dx;\n        closestPoint[1] = flatCoordinates[1] + delta * dy;\n        for (let i = 2; i < this.stride; ++i) {\n          closestPoint[i] = flatCoordinates[i];\n        }\n      }\n      closestPoint.length = this.stride;\n      return squaredDistance;\n    }\n    return minSquaredDistance;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   */\n  containsXY(x, y) {\n    const flatCoordinates = this.flatCoordinates;\n    const dx = x - flatCoordinates[0];\n    const dy = y - flatCoordinates[1];\n    return dx * dx + dy * dy <= this.getRadiusSquared_();\n  }\n\n  /**\n   * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\n   * @return {import(\"../coordinate.js\").Coordinate} Center.\n   * @api\n   */\n  getCenter() {\n    return this.flatCoordinates.slice(0, this.stride);\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @protected\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   */\n  computeExtent(extent) {\n    const flatCoordinates = this.flatCoordinates;\n    const radius = flatCoordinates[this.stride] - flatCoordinates[0];\n    return (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.createOrUpdate)(\n      flatCoordinates[0] - radius,\n      flatCoordinates[1] - radius,\n      flatCoordinates[0] + radius,\n      flatCoordinates[1] + radius,\n      extent,\n    );\n  }\n\n  /**\n   * Return the radius of the circle.\n   * @return {number} Radius.\n   * @api\n   */\n  getRadius() {\n    return Math.sqrt(this.getRadiusSquared_());\n  }\n\n  /**\n   * @private\n   * @return {number} Radius squared.\n   */\n  getRadiusSquared_() {\n    const dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];\n    const dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];\n    return dx * dx + dy * dy;\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   */\n  getType() {\n    return 'Circle';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n  intersectsExtent(extent) {\n    const circleExtent = this.getExtent();\n    if ((0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.intersects)(extent, circleExtent)) {\n      const center = this.getCenter();\n\n      if (extent[0] <= center[0] && extent[2] >= center[0]) {\n        return true;\n      }\n      if (extent[1] <= center[1] && extent[3] >= center[1]) {\n        return true;\n      }\n\n      return (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.forEachCorner)(extent, this.intersectsCoordinate.bind(this));\n    }\n    return false;\n  }\n\n  /**\n   * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\n   * @param {import(\"../coordinate.js\").Coordinate} center Center.\n   * @api\n   */\n  setCenter(center) {\n    const stride = this.stride;\n    const radius = this.flatCoordinates[stride] - this.flatCoordinates[0];\n    const flatCoordinates = center.slice();\n    flatCoordinates[stride] = flatCoordinates[0] + radius;\n    for (let i = 1; i < stride; ++i) {\n      flatCoordinates[stride + i] = center[i];\n    }\n    this.setFlatCoordinates(this.layout, flatCoordinates);\n    this.changed();\n  }\n\n  /**\n   * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as\n   * number) of the circle.\n   * @param {!import(\"../coordinate.js\").Coordinate} center Center.\n   * @param {number} radius Radius.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   */\n  setCenterAndRadius(center, radius, layout) {\n    this.setLayout(layout, center, 0);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    /** @type {Array<number>} */\n    const flatCoordinates = this.flatCoordinates;\n    let offset = (0,_flat_deflate_js__WEBPACK_IMPORTED_MODULE_2__.deflateCoordinate)(flatCoordinates, 0, center, this.stride);\n    flatCoordinates[offset++] = flatCoordinates[0] + radius;\n    for (let i = 1, ii = this.stride; i < ii; ++i) {\n      flatCoordinates[offset++] = flatCoordinates[i];\n    }\n    flatCoordinates.length = offset;\n    this.changed();\n  }\n\n  getCoordinates() {\n    return null;\n  }\n\n  setCoordinates(coordinates, layout) {}\n\n  /**\n   * Set the radius of the circle. The radius is in the units of the projection.\n   * @param {number} radius Radius.\n   * @api\n   */\n  setRadius(radius) {\n    this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;\n    this.changed();\n  }\n\n  /**\n   * Rotate the geometry around a given coordinate. This modifies the geometry\n   * coordinates in place.\n   * @param {number} angle Rotation angle in counter-clockwise radians.\n   * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n   * @api\n   */\n  rotate(angle, anchor) {\n    const center = this.getCenter();\n    const stride = this.getStride();\n    this.setCenter(\n      (0,_flat_transform_js__WEBPACK_IMPORTED_MODULE_3__.rotate)(center, 0, center.length, stride, angle, anchor, center),\n    );\n    this.changed();\n  }\n}\n\n/**\n * Transform each coordinate of the circle from one coordinate reference system\n * to another. The geometry is modified in place.\n * If you do not want the geometry modified in place, first clone() it and\n * then use this function on the clone.\n *\n * Internally a circle is currently represented by two points: the center of\n * the circle `[cx, cy]`, and the point to the right of the circle\n * `[cx + r, cy]`. This `transform` function just transforms these two points.\n * So the resulting geometry is also a circle, and that circle does not\n * correspond to the shape that would be obtained by transforming every point\n * of the original circle.\n *\n * @param {import(\"../proj.js\").ProjectionLike} source The current projection.  Can be a\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n * @param {import(\"../proj.js\").ProjectionLike} destination The desired projection.  Can be a\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n * @return {Circle} This geometry.  Note that original geometry is\n *     modified in place.\n * @function\n * @api\n */\nCircle.prototype.transform;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Circle);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vbC9nZW9tL0NpcmNsZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNpRDtBQUNzQjtBQUNuQjtBQUNUOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMERBQWM7QUFDbkM7QUFDQSxhQUFhLHdDQUF3QztBQUNyRDtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsd0NBQXdDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLHVDQUF1QztBQUNwRCxhQUFhLFFBQVE7QUFDckIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUMsaURBQWlEO0FBQzFGLGNBQWMsdUNBQXVDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLCtCQUErQjtBQUM1QztBQUNBLGNBQWMsK0JBQStCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywwREFBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsOEJBQThCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsK0JBQStCO0FBQzVDLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQVU7QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEseURBQWE7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDLGlEQUFpRDtBQUN2RixhQUFhLHVDQUF1QztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsaURBQWlEO0FBQzFFO0FBQ0EsYUFBYSx3Q0FBd0M7QUFDckQsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsd0NBQXdDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0EsaUJBQWlCLG1FQUFpQjtBQUNsQztBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLHVDQUF1QztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDBEQUFNO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFDQUFxQztBQUNoRCwrQkFBK0IsNENBQTRDO0FBQzNFLFdBQVcscUNBQXFDO0FBQ2hELCtCQUErQiw0Q0FBNEM7QUFDM0UsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBZSxNQUFNLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL29sL2dlb20vQ2lyY2xlLmpzP2MwMDYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vQ2lyY2xlXG4gKi9cbmltcG9ydCBTaW1wbGVHZW9tZXRyeSBmcm9tICcuL1NpbXBsZUdlb21ldHJ5LmpzJztcbmltcG9ydCB7Y3JlYXRlT3JVcGRhdGUsIGZvckVhY2hDb3JuZXIsIGludGVyc2VjdHN9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge2RlZmxhdGVDb29yZGluYXRlfSBmcm9tICcuL2ZsYXQvZGVmbGF0ZS5qcyc7XG5pbXBvcnQge3JvdGF0ZX0gZnJvbSAnLi9mbGF0L3RyYW5zZm9ybS5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQ2lyY2xlIGdlb21ldHJ5LlxuICpcbiAqIEBhcGlcbiAqL1xuY2xhc3MgQ2lyY2xlIGV4dGVuZHMgU2ltcGxlR2VvbWV0cnkge1xuICAvKipcbiAgICogQHBhcmFtIHshaW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjZW50ZXIgQ2VudGVyLlxuICAgKiAgICAgRm9yIGludGVybmFsIHVzZSwgZmxhdCBjb29yZGluYXRlcyBpbiBjb21iaW5hdGlvbiB3aXRoIGBsYXlvdXRgIGFuZCBub1xuICAgKiAgICAgYHJhZGl1c2AgYXJlIGFsc28gYWNjZXB0ZWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcmFkaXVzXSBSYWRpdXMgaW4gdW5pdHMgb2YgdGhlIHByb2plY3Rpb24uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9HZW9tZXRyeS5qc1wiKS5HZW9tZXRyeUxheW91dH0gW2xheW91dF0gTGF5b3V0LlxuICAgKi9cbiAgY29uc3RydWN0b3IoY2VudGVyLCByYWRpdXMsIGxheW91dCkge1xuICAgIHN1cGVyKCk7XG4gICAgaWYgKGxheW91dCAhPT0gdW5kZWZpbmVkICYmIHJhZGl1cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnNldEZsYXRDb29yZGluYXRlcyhsYXlvdXQsIGNlbnRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhZGl1cyA9IHJhZGl1cyA/IHJhZGl1cyA6IDA7XG4gICAgICB0aGlzLnNldENlbnRlckFuZFJhZGl1cyhjZW50ZXIsIHJhZGl1cywgbGF5b3V0KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWFrZSBhIGNvbXBsZXRlIGNvcHkgb2YgdGhlIGdlb21ldHJ5LlxuICAgKiBAcmV0dXJuIHshQ2lyY2xlfSBDbG9uZS5cbiAgICogQGFwaVxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgY2lyY2xlID0gbmV3IENpcmNsZShcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLnNsaWNlKCksXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB0aGlzLmxheW91dCxcbiAgICApO1xuICAgIGNpcmNsZS5hcHBseVByb3BlcnRpZXModGhpcyk7XG4gICAgcmV0dXJuIGNpcmNsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY2xvc2VzdFBvaW50IENsb3Nlc3QgcG9pbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5TcXVhcmVkRGlzdGFuY2UgTWluaW11bSBzcXVhcmVkIGRpc3RhbmNlLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE1pbmltdW0gc3F1YXJlZCBkaXN0YW5jZS5cbiAgICovXG4gIGNsb3Nlc3RQb2ludFhZKHgsIHksIGNsb3Nlc3RQb2ludCwgbWluU3F1YXJlZERpc3RhbmNlKSB7XG4gICAgY29uc3QgZmxhdENvb3JkaW5hdGVzID0gdGhpcy5mbGF0Q29vcmRpbmF0ZXM7XG4gICAgY29uc3QgZHggPSB4IC0gZmxhdENvb3JkaW5hdGVzWzBdO1xuICAgIGNvbnN0IGR5ID0geSAtIGZsYXRDb29yZGluYXRlc1sxXTtcbiAgICBjb25zdCBzcXVhcmVkRGlzdGFuY2UgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICBpZiAoc3F1YXJlZERpc3RhbmNlIDwgbWluU3F1YXJlZERpc3RhbmNlKSB7XG4gICAgICBpZiAoc3F1YXJlZERpc3RhbmNlID09PSAwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdHJpZGU7ICsraSkge1xuICAgICAgICAgIGNsb3Nlc3RQb2ludFtpXSA9IGZsYXRDb29yZGluYXRlc1tpXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZGVsdGEgPSB0aGlzLmdldFJhZGl1cygpIC8gTWF0aC5zcXJ0KHNxdWFyZWREaXN0YW5jZSk7XG4gICAgICAgIGNsb3Nlc3RQb2ludFswXSA9IGZsYXRDb29yZGluYXRlc1swXSArIGRlbHRhICogZHg7XG4gICAgICAgIGNsb3Nlc3RQb2ludFsxXSA9IGZsYXRDb29yZGluYXRlc1sxXSArIGRlbHRhICogZHk7XG4gICAgICAgIGZvciAobGV0IGkgPSAyOyBpIDwgdGhpcy5zdHJpZGU7ICsraSkge1xuICAgICAgICAgIGNsb3Nlc3RQb2ludFtpXSA9IGZsYXRDb29yZGluYXRlc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2xvc2VzdFBvaW50Lmxlbmd0aCA9IHRoaXMuc3RyaWRlO1xuICAgICAgcmV0dXJuIHNxdWFyZWREaXN0YW5jZTtcbiAgICB9XG4gICAgcmV0dXJuIG1pblNxdWFyZWREaXN0YW5jZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBDb250YWlucyAoeCwgeSkuXG4gICAqL1xuICBjb250YWluc1hZKHgsIHkpIHtcbiAgICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSB0aGlzLmZsYXRDb29yZGluYXRlcztcbiAgICBjb25zdCBkeCA9IHggLSBmbGF0Q29vcmRpbmF0ZXNbMF07XG4gICAgY29uc3QgZHkgPSB5IC0gZmxhdENvb3JkaW5hdGVzWzFdO1xuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeSA8PSB0aGlzLmdldFJhZGl1c1NxdWFyZWRfKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZSBhcyB7QGxpbmsgbW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZSBjb29yZGluYXRlfS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBDZW50ZXIuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldENlbnRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5mbGF0Q29vcmRpbmF0ZXMuc2xpY2UoMCwgdGhpcy5zdHJpZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKi9cbiAgY29tcHV0ZUV4dGVudChleHRlbnQpIHtcbiAgICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSB0aGlzLmZsYXRDb29yZGluYXRlcztcbiAgICBjb25zdCByYWRpdXMgPSBmbGF0Q29vcmRpbmF0ZXNbdGhpcy5zdHJpZGVdIC0gZmxhdENvb3JkaW5hdGVzWzBdO1xuICAgIHJldHVybiBjcmVhdGVPclVwZGF0ZShcbiAgICAgIGZsYXRDb29yZGluYXRlc1swXSAtIHJhZGl1cyxcbiAgICAgIGZsYXRDb29yZGluYXRlc1sxXSAtIHJhZGl1cyxcbiAgICAgIGZsYXRDb29yZGluYXRlc1swXSArIHJhZGl1cyxcbiAgICAgIGZsYXRDb29yZGluYXRlc1sxXSArIHJhZGl1cyxcbiAgICAgIGV4dGVudCxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgcmFkaXVzIG9mIHRoZSBjaXJjbGUuXG4gICAqIEByZXR1cm4ge251bWJlcn0gUmFkaXVzLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRSYWRpdXMoKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLmdldFJhZGl1c1NxdWFyZWRfKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge251bWJlcn0gUmFkaXVzIHNxdWFyZWQuXG4gICAqL1xuICBnZXRSYWRpdXNTcXVhcmVkXygpIHtcbiAgICBjb25zdCBkeCA9IHRoaXMuZmxhdENvb3JkaW5hdGVzW3RoaXMuc3RyaWRlXSAtIHRoaXMuZmxhdENvb3JkaW5hdGVzWzBdO1xuICAgIGNvbnN0IGR5ID0gdGhpcy5mbGF0Q29vcmRpbmF0ZXNbdGhpcy5zdHJpZGUgKyAxXSAtIHRoaXMuZmxhdENvb3JkaW5hdGVzWzFdO1xuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHR5cGUgb2YgdGhpcyBnZW9tZXRyeS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9HZW9tZXRyeS5qc1wiKS5UeXBlfSBHZW9tZXRyeSB0eXBlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRUeXBlKCkge1xuICAgIHJldHVybiAnQ2lyY2xlJztcbiAgfVxuXG4gIC8qKlxuICAgKiBUZXN0IGlmIHRoZSBnZW9tZXRyeSBhbmQgdGhlIHBhc3NlZCBleHRlbnQgaW50ZXJzZWN0LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgZ2VvbWV0cnkgYW5kIHRoZSBleHRlbnQgaW50ZXJzZWN0LlxuICAgKiBAYXBpXG4gICAqL1xuICBpbnRlcnNlY3RzRXh0ZW50KGV4dGVudCkge1xuICAgIGNvbnN0IGNpcmNsZUV4dGVudCA9IHRoaXMuZ2V0RXh0ZW50KCk7XG4gICAgaWYgKGludGVyc2VjdHMoZXh0ZW50LCBjaXJjbGVFeHRlbnQpKSB7XG4gICAgICBjb25zdCBjZW50ZXIgPSB0aGlzLmdldENlbnRlcigpO1xuXG4gICAgICBpZiAoZXh0ZW50WzBdIDw9IGNlbnRlclswXSAmJiBleHRlbnRbMl0gPj0gY2VudGVyWzBdKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGV4dGVudFsxXSA8PSBjZW50ZXJbMV0gJiYgZXh0ZW50WzNdID49IGNlbnRlclsxXSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZvckVhY2hDb3JuZXIoZXh0ZW50LCB0aGlzLmludGVyc2VjdHNDb29yZGluYXRlLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZSBhcyB7QGxpbmsgbW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZSBjb29yZGluYXRlfS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNlbnRlciBDZW50ZXIuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldENlbnRlcihjZW50ZXIpIHtcbiAgICBjb25zdCBzdHJpZGUgPSB0aGlzLnN0cmlkZTtcbiAgICBjb25zdCByYWRpdXMgPSB0aGlzLmZsYXRDb29yZGluYXRlc1tzdHJpZGVdIC0gdGhpcy5mbGF0Q29vcmRpbmF0ZXNbMF07XG4gICAgY29uc3QgZmxhdENvb3JkaW5hdGVzID0gY2VudGVyLnNsaWNlKCk7XG4gICAgZmxhdENvb3JkaW5hdGVzW3N0cmlkZV0gPSBmbGF0Q29vcmRpbmF0ZXNbMF0gKyByYWRpdXM7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzdHJpZGU7ICsraSkge1xuICAgICAgZmxhdENvb3JkaW5hdGVzW3N0cmlkZSArIGldID0gY2VudGVyW2ldO1xuICAgIH1cbiAgICB0aGlzLnNldEZsYXRDb29yZGluYXRlcyh0aGlzLmxheW91dCwgZmxhdENvb3JkaW5hdGVzKTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNlbnRlciAoYXMge0BsaW5rIG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGUgY29vcmRpbmF0ZX0pIGFuZCB0aGUgcmFkaXVzIChhc1xuICAgKiBudW1iZXIpIG9mIHRoZSBjaXJjbGUuXG4gICAqIEBwYXJhbSB7IWltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY2VudGVyIENlbnRlci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyBSYWRpdXMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9HZW9tZXRyeS5qc1wiKS5HZW9tZXRyeUxheW91dH0gW2xheW91dF0gTGF5b3V0LlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRDZW50ZXJBbmRSYWRpdXMoY2VudGVyLCByYWRpdXMsIGxheW91dCkge1xuICAgIHRoaXMuc2V0TGF5b3V0KGxheW91dCwgY2VudGVyLCAwKTtcbiAgICBpZiAoIXRoaXMuZmxhdENvb3JkaW5hdGVzKSB7XG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyA9IFtdO1xuICAgIH1cbiAgICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovXG4gICAgY29uc3QgZmxhdENvb3JkaW5hdGVzID0gdGhpcy5mbGF0Q29vcmRpbmF0ZXM7XG4gICAgbGV0IG9mZnNldCA9IGRlZmxhdGVDb29yZGluYXRlKGZsYXRDb29yZGluYXRlcywgMCwgY2VudGVyLCB0aGlzLnN0cmlkZSk7XG4gICAgZmxhdENvb3JkaW5hdGVzW29mZnNldCsrXSA9IGZsYXRDb29yZGluYXRlc1swXSArIHJhZGl1cztcbiAgICBmb3IgKGxldCBpID0gMSwgaWkgPSB0aGlzLnN0cmlkZTsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGZsYXRDb29yZGluYXRlc1tvZmZzZXQrK10gPSBmbGF0Q29vcmRpbmF0ZXNbaV07XG4gICAgfVxuICAgIGZsYXRDb29yZGluYXRlcy5sZW5ndGggPSBvZmZzZXQ7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cblxuICBnZXRDb29yZGluYXRlcygpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHNldENvb3JkaW5hdGVzKGNvb3JkaW5hdGVzLCBsYXlvdXQpIHt9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgcmFkaXVzIG9mIHRoZSBjaXJjbGUuIFRoZSByYWRpdXMgaXMgaW4gdGhlIHVuaXRzIG9mIHRoZSBwcm9qZWN0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIFJhZGl1cy5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0UmFkaXVzKHJhZGl1cykge1xuICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzW3RoaXMuc3RyaWRlXSA9IHRoaXMuZmxhdENvb3JkaW5hdGVzWzBdICsgcmFkaXVzO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJvdGF0ZSB0aGUgZ2VvbWV0cnkgYXJvdW5kIGEgZ2l2ZW4gY29vcmRpbmF0ZS4gVGhpcyBtb2RpZmllcyB0aGUgZ2VvbWV0cnlcbiAgICogY29vcmRpbmF0ZXMgaW4gcGxhY2UuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSBSb3RhdGlvbiBhbmdsZSBpbiBjb3VudGVyLWNsb2Nrd2lzZSByYWRpYW5zLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gYW5jaG9yIFRoZSByb3RhdGlvbiBjZW50ZXIuXG4gICAqIEBhcGlcbiAgICovXG4gIHJvdGF0ZShhbmdsZSwgYW5jaG9yKSB7XG4gICAgY29uc3QgY2VudGVyID0gdGhpcy5nZXRDZW50ZXIoKTtcbiAgICBjb25zdCBzdHJpZGUgPSB0aGlzLmdldFN0cmlkZSgpO1xuICAgIHRoaXMuc2V0Q2VudGVyKFxuICAgICAgcm90YXRlKGNlbnRlciwgMCwgY2VudGVyLmxlbmd0aCwgc3RyaWRlLCBhbmdsZSwgYW5jaG9yLCBjZW50ZXIpLFxuICAgICk7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gZWFjaCBjb29yZGluYXRlIG9mIHRoZSBjaXJjbGUgZnJvbSBvbmUgY29vcmRpbmF0ZSByZWZlcmVuY2Ugc3lzdGVtXG4gKiB0byBhbm90aGVyLiBUaGUgZ2VvbWV0cnkgaXMgbW9kaWZpZWQgaW4gcGxhY2UuXG4gKiBJZiB5b3UgZG8gbm90IHdhbnQgdGhlIGdlb21ldHJ5IG1vZGlmaWVkIGluIHBsYWNlLCBmaXJzdCBjbG9uZSgpIGl0IGFuZFxuICogdGhlbiB1c2UgdGhpcyBmdW5jdGlvbiBvbiB0aGUgY2xvbmUuXG4gKlxuICogSW50ZXJuYWxseSBhIGNpcmNsZSBpcyBjdXJyZW50bHkgcmVwcmVzZW50ZWQgYnkgdHdvIHBvaW50czogdGhlIGNlbnRlciBvZlxuICogdGhlIGNpcmNsZSBgW2N4LCBjeV1gLCBhbmQgdGhlIHBvaW50IHRvIHRoZSByaWdodCBvZiB0aGUgY2lyY2xlXG4gKiBgW2N4ICsgciwgY3ldYC4gVGhpcyBgdHJhbnNmb3JtYCBmdW5jdGlvbiBqdXN0IHRyYW5zZm9ybXMgdGhlc2UgdHdvIHBvaW50cy5cbiAqIFNvIHRoZSByZXN1bHRpbmcgZ2VvbWV0cnkgaXMgYWxzbyBhIGNpcmNsZSwgYW5kIHRoYXQgY2lyY2xlIGRvZXMgbm90XG4gKiBjb3JyZXNwb25kIHRvIHRoZSBzaGFwZSB0aGF0IHdvdWxkIGJlIG9idGFpbmVkIGJ5IHRyYW5zZm9ybWluZyBldmVyeSBwb2ludFxuICogb2YgdGhlIG9yaWdpbmFsIGNpcmNsZS5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ouanNcIikuUHJvamVjdGlvbkxpa2V9IHNvdXJjZSBUaGUgY3VycmVudCBwcm9qZWN0aW9uLiAgQ2FuIGJlIGFcbiAqICAgICBzdHJpbmcgaWRlbnRpZmllciBvciBhIHtAbGluayBtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9uflByb2plY3Rpb259IG9iamVjdC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5Qcm9qZWN0aW9uTGlrZX0gZGVzdGluYXRpb24gVGhlIGRlc2lyZWQgcHJvamVjdGlvbi4gIENhbiBiZSBhXG4gKiAgICAgc3RyaW5nIGlkZW50aWZpZXIgb3IgYSB7QGxpbmsgbW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn5Qcm9qZWN0aW9ufSBvYmplY3QuXG4gKiBAcmV0dXJuIHtDaXJjbGV9IFRoaXMgZ2VvbWV0cnkuICBOb3RlIHRoYXQgb3JpZ2luYWwgZ2VvbWV0cnkgaXNcbiAqICAgICBtb2RpZmllZCBpbiBwbGFjZS5cbiAqIEBmdW5jdGlvblxuICogQGFwaVxuICovXG5DaXJjbGUucHJvdG90eXBlLnRyYW5zZm9ybTtcbmV4cG9ydCBkZWZhdWx0IENpcmNsZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ol/geom/Circle.js\n"));

/***/ })

}]);