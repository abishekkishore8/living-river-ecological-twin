"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_ol_control_js"],{

/***/ "(app-pages-browser)/./node_modules/ol/Overlay.js":
/*!************************************!*\
  !*** ./node_modules/ol/Overlay.js ***!
  \************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Object.js */ \"(app-pages-browser)/./node_modules/ol/Object.js\");\n/* harmony import */ var _MapEventType_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MapEventType.js */ \"(app-pages-browser)/./node_modules/ol/MapEventType.js\");\n/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./css.js */ \"(app-pages-browser)/./node_modules/ol/css.js\");\n/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./extent.js */ \"(app-pages-browser)/./node_modules/ol/extent.js\");\n/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./events.js */ \"(app-pages-browser)/./node_modules/ol/events.js\");\n/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dom.js */ \"(app-pages-browser)/./node_modules/ol/dom.js\");\n/**\n * @module ol/Overlay\n */\n\n\n\n\n\n\n\n/**\n * @typedef {'bottom-left' | 'bottom-center' | 'bottom-right' | 'center-left' | 'center-center' | 'center-right' | 'top-left' | 'top-center' | 'top-right'} Positioning\n * The overlay position: `'bottom-left'`, `'bottom-center'`,  `'bottom-right'`,\n * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,\n * `'top-center'`, or `'top-right'`.\n */\n\n/**\n * @typedef {Object} Options\n * @property {number|string} [id] Set the overlay id. The overlay id can be used\n * with the {@link module:ol/Map~Map#getOverlayById} method.\n * @property {HTMLElement} [element] The overlay element.\n * @property {Array<number>} [offset=[0, 0]] Offsets in pixels used when positioning\n * the overlay. The first element in the\n * array is the horizontal offset. A positive value shifts the overlay right.\n * The second element in the array is the vertical offset. A positive value\n * shifts the overlay down.\n * @property {import(\"./coordinate.js\").Coordinate} [position] The overlay position\n * in map projection.\n * @property {Positioning} [positioning='top-left'] Defines how\n * the overlay is actually positioned with respect to its `position` property.\n * Possible values are `'bottom-left'`, `'bottom-center'`, `'bottom-right'`,\n * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,\n * `'top-center'`, and `'top-right'`.\n * @property {boolean} [stopEvent=true] Whether event propagation to the map\n * viewport should be stopped. If `true` the overlay is placed in the same\n * container as that of the controls (CSS class name\n * `ol-overlaycontainer-stopevent`); if `false` it is placed in the container\n * with CSS class name specified by the `className` property.\n * @property {boolean} [insertFirst=true] Whether the overlay is inserted first\n * in the overlay container, or appended. If the overlay is placed in the same\n * container as that of the controls (see the `stopEvent` option) you will\n * probably set `insertFirst` to `true` so the overlay is displayed below the\n * controls.\n * @property {PanIntoViewOptions|boolean} [autoPan=false] Pan the map when calling\n * `setPosition`, so that the overlay is entirely visible in the current viewport.\n * @property {string} [className='ol-overlay-container ol-selectable'] CSS class\n * name.\n */\n\n/**\n * @typedef {Object} PanOptions\n * @property {number} [duration=1000] The duration of the animation in\n * milliseconds.\n * @property {function(number):number} [easing] The easing function to use. Can\n * be one from {@link module:ol/easing} or a custom function.\n * Default is {@link module:ol/easing.inAndOut}.\n */\n\n/**\n * @typedef {Object} PanIntoViewOptions\n * @property {PanOptions} [animation={}] The animation parameters for the pan\n * @property {number} [margin=20] The margin (in pixels) between the\n * overlay and the borders of the map when panning into view.\n */\n\n/**\n * @enum {string}\n * @protected\n */\nconst Property = {\n  ELEMENT: 'element',\n  MAP: 'map',\n  OFFSET: 'offset',\n  POSITION: 'position',\n  POSITIONING: 'positioning',\n};\n\n/**\n * @typedef {import(\"./ObjectEventType\").Types|'change:element'|'change:map'|'change:offset'|'change:position'|\n *   'change:positioning'} OverlayObjectEventTypes\n */\n\n/***\n * @template Return\n * @typedef {import(\"./Observable\").OnSignature<import(\"./Observable\").EventTypes, import(\"./events/Event.js\").default, Return> &\n *   import(\"./Observable\").OnSignature<OverlayObjectEventTypes, import(\"./Object\").ObjectEvent, Return> &\n *   import(\"./Observable\").CombinedOnSignature<import(\"./Observable\").EventTypes|OverlayObjectEventTypes, Return>} OverlayOnSignature\n */\n\n/**\n * @classdesc\n * An element to be displayed over the map and attached to a single map\n * location.  Like {@link module:ol/control/Control~Control}, Overlays are\n * visible widgets. Unlike Controls, they are not in a fixed position on the\n * screen, but are tied to a geographical coordinate, so panning the map will\n * move an Overlay but not a Control.\n *\n * Example:\n *\n *     import Overlay from 'ol/Overlay.js';\n *\n *     // ...\n *     const popup = new Overlay({\n *       element: document.getElementById('popup'),\n *     });\n *     popup.setPosition(coordinate);\n *     map.addOverlay(popup);\n *\n * @api\n */\nclass Overlay extends _Object_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  /**\n   * @param {Options} options Overlay options.\n   */\n  constructor(options) {\n    super();\n\n    /***\n     * @type {OverlayOnSignature<import(\"./events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {OverlayOnSignature<import(\"./events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {OverlayOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @protected\n     * @type {Options}\n     */\n    this.options = options;\n\n    /**\n     * @protected\n     * @type {number|string|undefined}\n     */\n    this.id = options.id;\n\n    /**\n     * @protected\n     * @type {boolean}\n     */\n    this.insertFirst =\n      options.insertFirst !== undefined ? options.insertFirst : true;\n\n    /**\n     * @protected\n     * @type {boolean}\n     */\n    this.stopEvent = options.stopEvent !== undefined ? options.stopEvent : true;\n\n    /**\n     * @protected\n     * @type {HTMLElement}\n     */\n    this.element = document.createElement('div');\n    this.element.className =\n      options.className !== undefined\n        ? options.className\n        : 'ol-overlay-container ' + _css_js__WEBPACK_IMPORTED_MODULE_1__.CLASS_SELECTABLE;\n    this.element.style.position = 'absolute';\n    this.element.style.pointerEvents = 'auto';\n\n    /**\n     * @protected\n     * @type {PanIntoViewOptions|undefined}\n     */\n    this.autoPan = options.autoPan === true ? {} : options.autoPan || undefined;\n\n    /**\n     * @protected\n     * @type {{transform_: string,\n     *         visible: boolean}}\n     */\n    this.rendered = {\n      transform_: '',\n      visible: true,\n    };\n\n    /**\n     * @protected\n     * @type {?import(\"./events.js\").EventsKey}\n     */\n    this.mapPostrenderListenerKey = null;\n\n    this.addChangeListener(Property.ELEMENT, this.handleElementChanged);\n    this.addChangeListener(Property.MAP, this.handleMapChanged);\n    this.addChangeListener(Property.OFFSET, this.handleOffsetChanged);\n    this.addChangeListener(Property.POSITION, this.handlePositionChanged);\n    this.addChangeListener(Property.POSITIONING, this.handlePositioningChanged);\n\n    if (options.element !== undefined) {\n      this.setElement(options.element);\n    }\n\n    this.setOffset(options.offset !== undefined ? options.offset : [0, 0]);\n\n    this.setPositioning(options.positioning || 'top-left');\n\n    if (options.position !== undefined) {\n      this.setPosition(options.position);\n    }\n  }\n\n  /**\n   * Get the DOM element of this overlay.\n   * @return {HTMLElement|undefined} The Element containing the overlay.\n   * @observable\n   * @api\n   */\n  getElement() {\n    return /** @type {HTMLElement|undefined} */ (this.get(Property.ELEMENT));\n  }\n\n  /**\n   * Get the overlay identifier which is set on constructor.\n   * @return {number|string|undefined} Id.\n   * @api\n   */\n  getId() {\n    return this.id;\n  }\n\n  /**\n   * Get the map associated with this overlay.\n   * @return {import(\"./Map.js\").default|null} The map that the\n   * overlay is part of.\n   * @observable\n   * @api\n   */\n  getMap() {\n    return /** @type {import(\"./Map.js\").default|null} */ (\n      this.get(Property.MAP) || null\n    );\n  }\n\n  /**\n   * Get the offset of this overlay.\n   * @return {Array<number>} The offset.\n   * @observable\n   * @api\n   */\n  getOffset() {\n    return /** @type {Array<number>} */ (this.get(Property.OFFSET));\n  }\n\n  /**\n   * Get the current position of this overlay.\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} The spatial point that the overlay is\n   *     anchored at.\n   * @observable\n   * @api\n   */\n  getPosition() {\n    return /** @type {import(\"./coordinate.js\").Coordinate|undefined} */ (\n      this.get(Property.POSITION)\n    );\n  }\n\n  /**\n   * Get the current positioning of this overlay.\n   * @return {Positioning} How the overlay is positioned\n   *     relative to its point on the map.\n   * @observable\n   * @api\n   */\n  getPositioning() {\n    return /** @type {Positioning} */ (this.get(Property.POSITIONING));\n  }\n\n  /**\n   * @protected\n   */\n  handleElementChanged() {\n    (0,_dom_js__WEBPACK_IMPORTED_MODULE_2__.removeChildren)(this.element);\n    const element = this.getElement();\n    if (element) {\n      this.element.appendChild(element);\n    }\n  }\n\n  /**\n   * @protected\n   */\n  handleMapChanged() {\n    if (this.mapPostrenderListenerKey) {\n      (0,_dom_js__WEBPACK_IMPORTED_MODULE_2__.removeNode)(this.element);\n      (0,_events_js__WEBPACK_IMPORTED_MODULE_3__.unlistenByKey)(this.mapPostrenderListenerKey);\n      this.mapPostrenderListenerKey = null;\n    }\n    const map = this.getMap();\n    if (map) {\n      this.mapPostrenderListenerKey = (0,_events_js__WEBPACK_IMPORTED_MODULE_3__.listen)(\n        map,\n        _MapEventType_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].POSTRENDER,\n        this.render,\n        this,\n      );\n      this.updatePixelPosition();\n      const container = this.stopEvent\n        ? map.getOverlayContainerStopEvent()\n        : map.getOverlayContainer();\n      if (this.insertFirst) {\n        container.insertBefore(this.element, container.childNodes[0] || null);\n      } else {\n        container.appendChild(this.element);\n      }\n      this.performAutoPan();\n    }\n  }\n\n  /**\n   * @protected\n   */\n  render() {\n    this.updatePixelPosition();\n  }\n\n  /**\n   * @protected\n   */\n  handleOffsetChanged() {\n    this.updatePixelPosition();\n  }\n\n  /**\n   * @protected\n   */\n  handlePositionChanged() {\n    this.updatePixelPosition();\n    this.performAutoPan();\n  }\n\n  /**\n   * @protected\n   */\n  handlePositioningChanged() {\n    this.updatePixelPosition();\n  }\n\n  /**\n   * Set the DOM element to be associated with this overlay.\n   * @param {HTMLElement|undefined} element The Element containing the overlay.\n   * @observable\n   * @api\n   */\n  setElement(element) {\n    this.set(Property.ELEMENT, element);\n  }\n\n  /**\n   * Set the map to be associated with this overlay.\n   * @param {import(\"./Map.js\").default|null} map The map that the\n   * overlay is part of. Pass `null` to just remove the overlay from the current map.\n   * @observable\n   * @api\n   */\n  setMap(map) {\n    this.set(Property.MAP, map);\n  }\n\n  /**\n   * Set the offset for this overlay.\n   * @param {Array<number>} offset Offset.\n   * @observable\n   * @api\n   */\n  setOffset(offset) {\n    this.set(Property.OFFSET, offset);\n  }\n\n  /**\n   * Set the position for this overlay. If the position is `undefined` the\n   * overlay is hidden.\n   * @param {import(\"./coordinate.js\").Coordinate|undefined} position The spatial point that the overlay\n   *     is anchored at.\n   * @observable\n   * @api\n   */\n  setPosition(position) {\n    this.set(Property.POSITION, position);\n  }\n\n  /**\n   * Pan the map so that the overlay is entirely visible in the current viewport\n   * (if necessary) using the configured autoPan parameters\n   * @protected\n   */\n  performAutoPan() {\n    if (this.autoPan) {\n      this.panIntoView(this.autoPan);\n    }\n  }\n\n  /**\n   * Pan the map so that the overlay is entirely visible in the current viewport\n   * (if necessary).\n   * @param {PanIntoViewOptions} [panIntoViewOptions] Options for the pan action\n   * @api\n   */\n  panIntoView(panIntoViewOptions) {\n    const map = this.getMap();\n\n    if (!map || !map.getTargetElement() || !this.get(Property.POSITION)) {\n      return;\n    }\n\n    const mapRect = this.getRect(map.getTargetElement(), map.getSize());\n    const element = this.getElement();\n    const overlayRect = this.getRect(element, [\n      (0,_dom_js__WEBPACK_IMPORTED_MODULE_2__.outerWidth)(element),\n      (0,_dom_js__WEBPACK_IMPORTED_MODULE_2__.outerHeight)(element),\n    ]);\n\n    panIntoViewOptions = panIntoViewOptions || {};\n\n    const myMargin =\n      panIntoViewOptions.margin === undefined ? 20 : panIntoViewOptions.margin;\n    if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_5__.containsExtent)(mapRect, overlayRect)) {\n      // the overlay is not completely inside the viewport, so pan the map\n      const offsetLeft = overlayRect[0] - mapRect[0];\n      const offsetRight = mapRect[2] - overlayRect[2];\n      const offsetTop = overlayRect[1] - mapRect[1];\n      const offsetBottom = mapRect[3] - overlayRect[3];\n\n      const delta = [0, 0];\n      if (offsetLeft < 0) {\n        // move map to the left\n        delta[0] = offsetLeft - myMargin;\n      } else if (offsetRight < 0) {\n        // move map to the right\n        delta[0] = Math.abs(offsetRight) + myMargin;\n      }\n      if (offsetTop < 0) {\n        // move map up\n        delta[1] = offsetTop - myMargin;\n      } else if (offsetBottom < 0) {\n        // move map down\n        delta[1] = Math.abs(offsetBottom) + myMargin;\n      }\n\n      if (delta[0] !== 0 || delta[1] !== 0) {\n        const center = /** @type {import(\"./coordinate.js\").Coordinate} */ (\n          map.getView().getCenterInternal()\n        );\n        const centerPx = map.getPixelFromCoordinateInternal(center);\n        if (!centerPx) {\n          return;\n        }\n        const newCenterPx = [centerPx[0] + delta[0], centerPx[1] + delta[1]];\n\n        const panOptions = panIntoViewOptions.animation || {};\n        map.getView().animateInternal({\n          center: map.getCoordinateFromPixelInternal(newCenterPx),\n          duration: panOptions.duration,\n          easing: panOptions.easing,\n        });\n      }\n    }\n  }\n\n  /**\n   * Get the extent of an element relative to the document\n   * @param {HTMLElement} element The element.\n   * @param {import(\"./size.js\").Size} size The size of the element.\n   * @return {import(\"./extent.js\").Extent} The extent.\n   * @protected\n   */\n  getRect(element, size) {\n    const box = element.getBoundingClientRect();\n    const offsetX = box.left + window.pageXOffset;\n    const offsetY = box.top + window.pageYOffset;\n    return [offsetX, offsetY, offsetX + size[0], offsetY + size[1]];\n  }\n\n  /**\n   * Set the positioning for this overlay.\n   * @param {Positioning} positioning how the overlay is\n   *     positioned relative to its point on the map.\n   * @observable\n   * @api\n   */\n  setPositioning(positioning) {\n    this.set(Property.POSITIONING, positioning);\n  }\n\n  /**\n   * Modify the visibility of the element.\n   * @param {boolean} visible Element visibility.\n   * @protected\n   */\n  setVisible(visible) {\n    if (this.rendered.visible !== visible) {\n      this.element.style.display = visible ? '' : 'none';\n      this.rendered.visible = visible;\n    }\n  }\n\n  /**\n   * Update pixel position.\n   * @protected\n   */\n  updatePixelPosition() {\n    const map = this.getMap();\n    const position = this.getPosition();\n    if (!map || !map.isRendered() || !position) {\n      this.setVisible(false);\n      return;\n    }\n\n    const pixel = map.getPixelFromCoordinate(position);\n    const mapSize = map.getSize();\n    this.updateRenderedPosition(pixel, mapSize);\n  }\n\n  /**\n   * @param {import(\"./pixel.js\").Pixel} pixel The pixel location.\n   * @param {import(\"./size.js\").Size|undefined} mapSize The map size.\n   * @protected\n   */\n  updateRenderedPosition(pixel, mapSize) {\n    const style = this.element.style;\n    const offset = this.getOffset();\n\n    const positioning = this.getPositioning();\n\n    this.setVisible(true);\n\n    const x = Math.round(pixel[0] + offset[0]) + 'px';\n    const y = Math.round(pixel[1] + offset[1]) + 'px';\n    let posX = '0%';\n    let posY = '0%';\n    if (\n      positioning == 'bottom-right' ||\n      positioning == 'center-right' ||\n      positioning == 'top-right'\n    ) {\n      posX = '-100%';\n    } else if (\n      positioning == 'bottom-center' ||\n      positioning == 'center-center' ||\n      positioning == 'top-center'\n    ) {\n      posX = '-50%';\n    }\n    if (\n      positioning == 'bottom-left' ||\n      positioning == 'bottom-center' ||\n      positioning == 'bottom-right'\n    ) {\n      posY = '-100%';\n    } else if (\n      positioning == 'center-left' ||\n      positioning == 'center-center' ||\n      positioning == 'center-right'\n    ) {\n      posY = '-50%';\n    }\n    const transform = `translate(${posX}, ${posY}) translate(${x}, ${y})`;\n    if (this.rendered.transform_ != transform) {\n      this.rendered.transform_ = transform;\n      style.transform = transform;\n    }\n  }\n\n  /**\n   * returns the options this Overlay has been created with\n   * @return {Options} overlay options\n   */\n  getOptions() {\n    return this.options;\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Overlay);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vbC9PdmVybGF5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDcUM7QUFDUTtBQUNIO0FBQ0M7QUFDTztBQUMyQjs7QUFFN0U7QUFDQSxhQUFhLCtJQUErSTtBQUM1SjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLGVBQWU7QUFDN0IsYUFBYSx3Q0FBd0M7QUFDckQsY0FBYyxhQUFhO0FBQzNCLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsc0NBQXNDO0FBQ3BEO0FBQ0EsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDRCQUE0QjtBQUMxQztBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGNBQWMseUJBQXlCO0FBQ3ZDLGdCQUFnQix3QkFBd0I7QUFDeEMsZUFBZSxnQ0FBZ0M7QUFDL0M7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxZQUFZLGFBQWE7QUFDdkMsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiLDJCQUEyQjtBQUMzQjs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esb0hBQW9IO0FBQ3BIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3Q0FBd0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNB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QUVBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrREFBZSxPQUFPLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL29sL092ZXJsYXkuanM/ODU5NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvT3ZlcmxheVxuICovXG5pbXBvcnQgQmFzZU9iamVjdCBmcm9tICcuL09iamVjdC5qcyc7XG5pbXBvcnQgTWFwRXZlbnRUeXBlIGZyb20gJy4vTWFwRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7Q0xBU1NfU0VMRUNUQUJMRX0gZnJvbSAnLi9jc3MuanMnO1xuaW1wb3J0IHtjb250YWluc0V4dGVudH0gZnJvbSAnLi9leHRlbnQuanMnO1xuaW1wb3J0IHtsaXN0ZW4sIHVubGlzdGVuQnlLZXl9IGZyb20gJy4vZXZlbnRzLmpzJztcbmltcG9ydCB7b3V0ZXJIZWlnaHQsIG91dGVyV2lkdGgsIHJlbW92ZUNoaWxkcmVuLCByZW1vdmVOb2RlfSBmcm9tICcuL2RvbS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeydib3R0b20tbGVmdCcgfCAnYm90dG9tLWNlbnRlcicgfCAnYm90dG9tLXJpZ2h0JyB8ICdjZW50ZXItbGVmdCcgfCAnY2VudGVyLWNlbnRlcicgfCAnY2VudGVyLXJpZ2h0JyB8ICd0b3AtbGVmdCcgfCAndG9wLWNlbnRlcicgfCAndG9wLXJpZ2h0J30gUG9zaXRpb25pbmdcbiAqIFRoZSBvdmVybGF5IHBvc2l0aW9uOiBgJ2JvdHRvbS1sZWZ0J2AsIGAnYm90dG9tLWNlbnRlcidgLCAgYCdib3R0b20tcmlnaHQnYCxcbiAqIGAnY2VudGVyLWxlZnQnYCwgYCdjZW50ZXItY2VudGVyJ2AsIGAnY2VudGVyLXJpZ2h0J2AsIGAndG9wLWxlZnQnYCxcbiAqIGAndG9wLWNlbnRlcidgLCBvciBgJ3RvcC1yaWdodCdgLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ8c3RyaW5nfSBbaWRdIFNldCB0aGUgb3ZlcmxheSBpZC4gVGhlIG92ZXJsYXkgaWQgY2FuIGJlIHVzZWRcbiAqIHdpdGggdGhlIHtAbGluayBtb2R1bGU6b2wvTWFwfk1hcCNnZXRPdmVybGF5QnlJZH0gbWV0aG9kLlxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gW2VsZW1lbnRdIFRoZSBvdmVybGF5IGVsZW1lbnQuXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IFtvZmZzZXQ9WzAsIDBdXSBPZmZzZXRzIGluIHBpeGVscyB1c2VkIHdoZW4gcG9zaXRpb25pbmdcbiAqIHRoZSBvdmVybGF5LiBUaGUgZmlyc3QgZWxlbWVudCBpbiB0aGVcbiAqIGFycmF5IGlzIHRoZSBob3Jpem9udGFsIG9mZnNldC4gQSBwb3NpdGl2ZSB2YWx1ZSBzaGlmdHMgdGhlIG92ZXJsYXkgcmlnaHQuXG4gKiBUaGUgc2Vjb25kIGVsZW1lbnQgaW4gdGhlIGFycmF5IGlzIHRoZSB2ZXJ0aWNhbCBvZmZzZXQuIEEgcG9zaXRpdmUgdmFsdWVcbiAqIHNoaWZ0cyB0aGUgb3ZlcmxheSBkb3duLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gW3Bvc2l0aW9uXSBUaGUgb3ZlcmxheSBwb3NpdGlvblxuICogaW4gbWFwIHByb2plY3Rpb24uXG4gKiBAcHJvcGVydHkge1Bvc2l0aW9uaW5nfSBbcG9zaXRpb25pbmc9J3RvcC1sZWZ0J10gRGVmaW5lcyBob3dcbiAqIHRoZSBvdmVybGF5IGlzIGFjdHVhbGx5IHBvc2l0aW9uZWQgd2l0aCByZXNwZWN0IHRvIGl0cyBgcG9zaXRpb25gIHByb3BlcnR5LlxuICogUG9zc2libGUgdmFsdWVzIGFyZSBgJ2JvdHRvbS1sZWZ0J2AsIGAnYm90dG9tLWNlbnRlcidgLCBgJ2JvdHRvbS1yaWdodCdgLFxuICogYCdjZW50ZXItbGVmdCdgLCBgJ2NlbnRlci1jZW50ZXInYCwgYCdjZW50ZXItcmlnaHQnYCwgYCd0b3AtbGVmdCdgLFxuICogYCd0b3AtY2VudGVyJ2AsIGFuZCBgJ3RvcC1yaWdodCdgLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbc3RvcEV2ZW50PXRydWVdIFdoZXRoZXIgZXZlbnQgcHJvcGFnYXRpb24gdG8gdGhlIG1hcFxuICogdmlld3BvcnQgc2hvdWxkIGJlIHN0b3BwZWQuIElmIGB0cnVlYCB0aGUgb3ZlcmxheSBpcyBwbGFjZWQgaW4gdGhlIHNhbWVcbiAqIGNvbnRhaW5lciBhcyB0aGF0IG9mIHRoZSBjb250cm9scyAoQ1NTIGNsYXNzIG5hbWVcbiAqIGBvbC1vdmVybGF5Y29udGFpbmVyLXN0b3BldmVudGApOyBpZiBgZmFsc2VgIGl0IGlzIHBsYWNlZCBpbiB0aGUgY29udGFpbmVyXG4gKiB3aXRoIENTUyBjbGFzcyBuYW1lIHNwZWNpZmllZCBieSB0aGUgYGNsYXNzTmFtZWAgcHJvcGVydHkuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpbnNlcnRGaXJzdD10cnVlXSBXaGV0aGVyIHRoZSBvdmVybGF5IGlzIGluc2VydGVkIGZpcnN0XG4gKiBpbiB0aGUgb3ZlcmxheSBjb250YWluZXIsIG9yIGFwcGVuZGVkLiBJZiB0aGUgb3ZlcmxheSBpcyBwbGFjZWQgaW4gdGhlIHNhbWVcbiAqIGNvbnRhaW5lciBhcyB0aGF0IG9mIHRoZSBjb250cm9scyAoc2VlIHRoZSBgc3RvcEV2ZW50YCBvcHRpb24pIHlvdSB3aWxsXG4gKiBwcm9iYWJseSBzZXQgYGluc2VydEZpcnN0YCB0byBgdHJ1ZWAgc28gdGhlIG92ZXJsYXkgaXMgZGlzcGxheWVkIGJlbG93IHRoZVxuICogY29udHJvbHMuXG4gKiBAcHJvcGVydHkge1BhbkludG9WaWV3T3B0aW9uc3xib29sZWFufSBbYXV0b1Bhbj1mYWxzZV0gUGFuIHRoZSBtYXAgd2hlbiBjYWxsaW5nXG4gKiBgc2V0UG9zaXRpb25gLCBzbyB0aGF0IHRoZSBvdmVybGF5IGlzIGVudGlyZWx5IHZpc2libGUgaW4gdGhlIGN1cnJlbnQgdmlld3BvcnQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzTmFtZT0nb2wtb3ZlcmxheS1jb250YWluZXIgb2wtc2VsZWN0YWJsZSddIENTUyBjbGFzc1xuICogbmFtZS5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFBhbk9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHVyYXRpb249MTAwMF0gVGhlIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24gaW5cbiAqIG1pbGxpc2Vjb25kcy5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24obnVtYmVyKTpudW1iZXJ9IFtlYXNpbmddIFRoZSBlYXNpbmcgZnVuY3Rpb24gdG8gdXNlLiBDYW5cbiAqIGJlIG9uZSBmcm9tIHtAbGluayBtb2R1bGU6b2wvZWFzaW5nfSBvciBhIGN1c3RvbSBmdW5jdGlvbi5cbiAqIERlZmF1bHQgaXMge0BsaW5rIG1vZHVsZTpvbC9lYXNpbmcuaW5BbmRPdXR9LlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUGFuSW50b1ZpZXdPcHRpb25zXG4gKiBAcHJvcGVydHkge1Bhbk9wdGlvbnN9IFthbmltYXRpb249e31dIFRoZSBhbmltYXRpb24gcGFyYW1ldGVycyBmb3IgdGhlIHBhblxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXJnaW49MjBdIFRoZSBtYXJnaW4gKGluIHBpeGVscykgYmV0d2VlbiB0aGVcbiAqIG92ZXJsYXkgYW5kIHRoZSBib3JkZXJzIG9mIHRoZSBtYXAgd2hlbiBwYW5uaW5nIGludG8gdmlldy5cbiAqL1xuXG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKiBAcHJvdGVjdGVkXG4gKi9cbmNvbnN0IFByb3BlcnR5ID0ge1xuICBFTEVNRU5UOiAnZWxlbWVudCcsXG4gIE1BUDogJ21hcCcsXG4gIE9GRlNFVDogJ29mZnNldCcsXG4gIFBPU0lUSU9OOiAncG9zaXRpb24nLFxuICBQT1NJVElPTklORzogJ3Bvc2l0aW9uaW5nJyxcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydChcIi4vT2JqZWN0RXZlbnRUeXBlXCIpLlR5cGVzfCdjaGFuZ2U6ZWxlbWVudCd8J2NoYW5nZTptYXAnfCdjaGFuZ2U6b2Zmc2V0J3wnY2hhbmdlOnBvc2l0aW9uJ3xcbiAqICAgJ2NoYW5nZTpwb3NpdGlvbmluZyd9IE92ZXJsYXlPYmplY3RFdmVudFR5cGVzXG4gKi9cblxuLyoqKlxuICogQHRlbXBsYXRlIFJldHVyblxuICogQHR5cGVkZWYge2ltcG9ydChcIi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxpbXBvcnQoXCIuL09ic2VydmFibGVcIikuRXZlbnRUeXBlcywgaW1wb3J0KFwiLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdCwgUmV0dXJuPiAmXG4gKiAgIGltcG9ydChcIi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxPdmVybGF5T2JqZWN0RXZlbnRUeXBlcywgaW1wb3J0KFwiLi9PYmplY3RcIikuT2JqZWN0RXZlbnQsIFJldHVybj4gJlxuICogICBpbXBvcnQoXCIuL09ic2VydmFibGVcIikuQ29tYmluZWRPblNpZ25hdHVyZTxpbXBvcnQoXCIuL09ic2VydmFibGVcIikuRXZlbnRUeXBlc3xPdmVybGF5T2JqZWN0RXZlbnRUeXBlcywgUmV0dXJuPn0gT3ZlcmxheU9uU2lnbmF0dXJlXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBbiBlbGVtZW50IHRvIGJlIGRpc3BsYXllZCBvdmVyIHRoZSBtYXAgYW5kIGF0dGFjaGVkIHRvIGEgc2luZ2xlIG1hcFxuICogbG9jYXRpb24uICBMaWtlIHtAbGluayBtb2R1bGU6b2wvY29udHJvbC9Db250cm9sfkNvbnRyb2x9LCBPdmVybGF5cyBhcmVcbiAqIHZpc2libGUgd2lkZ2V0cy4gVW5saWtlIENvbnRyb2xzLCB0aGV5IGFyZSBub3QgaW4gYSBmaXhlZCBwb3NpdGlvbiBvbiB0aGVcbiAqIHNjcmVlbiwgYnV0IGFyZSB0aWVkIHRvIGEgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUsIHNvIHBhbm5pbmcgdGhlIG1hcCB3aWxsXG4gKiBtb3ZlIGFuIE92ZXJsYXkgYnV0IG5vdCBhIENvbnRyb2wuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgaW1wb3J0IE92ZXJsYXkgZnJvbSAnb2wvT3ZlcmxheS5qcyc7XG4gKlxuICogICAgIC8vIC4uLlxuICogICAgIGNvbnN0IHBvcHVwID0gbmV3IE92ZXJsYXkoe1xuICogICAgICAgZWxlbWVudDogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BvcHVwJyksXG4gKiAgICAgfSk7XG4gKiAgICAgcG9wdXAuc2V0UG9zaXRpb24oY29vcmRpbmF0ZSk7XG4gKiAgICAgbWFwLmFkZE92ZXJsYXkocG9wdXApO1xuICpcbiAqIEBhcGlcbiAqL1xuY2xhc3MgT3ZlcmxheSBleHRlbmRzIEJhc2VPYmplY3Qge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zIE92ZXJsYXkgb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtPdmVybGF5T25TaWduYXR1cmU8aW1wb3J0KFwiLi9ldmVudHNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLm9uO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtPdmVybGF5T25TaWduYXR1cmU8aW1wb3J0KFwiLi9ldmVudHNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLm9uY2U7XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge092ZXJsYXlPblNpZ25hdHVyZTx2b2lkPn1cbiAgICAgKi9cbiAgICB0aGlzLnVuO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtPcHRpb25zfVxuICAgICAqL1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge251bWJlcnxzdHJpbmd8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuaWQgPSBvcHRpb25zLmlkO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuaW5zZXJ0Rmlyc3QgPVxuICAgICAgb3B0aW9ucy5pbnNlcnRGaXJzdCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5pbnNlcnRGaXJzdCA6IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5zdG9wRXZlbnQgPSBvcHRpb25zLnN0b3BFdmVudCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zdG9wRXZlbnQgOiB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmVsZW1lbnQuY2xhc3NOYW1lID1cbiAgICAgIG9wdGlvbnMuY2xhc3NOYW1lICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBvcHRpb25zLmNsYXNzTmFtZVxuICAgICAgICA6ICdvbC1vdmVybGF5LWNvbnRhaW5lciAnICsgQ0xBU1NfU0VMRUNUQUJMRTtcbiAgICB0aGlzLmVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIHRoaXMuZWxlbWVudC5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ2F1dG8nO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtQYW5JbnRvVmlld09wdGlvbnN8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuYXV0b1BhbiA9IG9wdGlvbnMuYXV0b1BhbiA9PT0gdHJ1ZSA/IHt9IDogb3B0aW9ucy5hdXRvUGFuIHx8IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7e3RyYW5zZm9ybV86IHN0cmluZyxcbiAgICAgKiAgICAgICAgIHZpc2libGU6IGJvb2xlYW59fVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyZWQgPSB7XG4gICAgICB0cmFuc2Zvcm1fOiAnJyxcbiAgICAgIHZpc2libGU6IHRydWUsXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleX1cbiAgICAgKi9cbiAgICB0aGlzLm1hcFBvc3RyZW5kZXJMaXN0ZW5lcktleSA9IG51bGw7XG5cbiAgICB0aGlzLmFkZENoYW5nZUxpc3RlbmVyKFByb3BlcnR5LkVMRU1FTlQsIHRoaXMuaGFuZGxlRWxlbWVudENoYW5nZWQpO1xuICAgIHRoaXMuYWRkQ2hhbmdlTGlzdGVuZXIoUHJvcGVydHkuTUFQLCB0aGlzLmhhbmRsZU1hcENoYW5nZWQpO1xuICAgIHRoaXMuYWRkQ2hhbmdlTGlzdGVuZXIoUHJvcGVydHkuT0ZGU0VULCB0aGlzLmhhbmRsZU9mZnNldENoYW5nZWQpO1xuICAgIHRoaXMuYWRkQ2hhbmdlTGlzdGVuZXIoUHJvcGVydHkuUE9TSVRJT04sIHRoaXMuaGFuZGxlUG9zaXRpb25DaGFuZ2VkKTtcbiAgICB0aGlzLmFkZENoYW5nZUxpc3RlbmVyKFByb3BlcnR5LlBPU0lUSU9OSU5HLCB0aGlzLmhhbmRsZVBvc2l0aW9uaW5nQ2hhbmdlZCk7XG5cbiAgICBpZiAob3B0aW9ucy5lbGVtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuc2V0RWxlbWVudChvcHRpb25zLmVsZW1lbnQpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0T2Zmc2V0KG9wdGlvbnMub2Zmc2V0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm9mZnNldCA6IFswLCAwXSk7XG5cbiAgICB0aGlzLnNldFBvc2l0aW9uaW5nKG9wdGlvbnMucG9zaXRpb25pbmcgfHwgJ3RvcC1sZWZ0Jyk7XG5cbiAgICBpZiAob3B0aW9ucy5wb3NpdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnNldFBvc2l0aW9uKG9wdGlvbnMucG9zaXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIERPTSBlbGVtZW50IG9mIHRoaXMgb3ZlcmxheS5cbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR8dW5kZWZpbmVkfSBUaGUgRWxlbWVudCBjb250YWluaW5nIHRoZSBvdmVybGF5LlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRFbGVtZW50KCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge0hUTUxFbGVtZW50fHVuZGVmaW5lZH0gKi8gKHRoaXMuZ2V0KFByb3BlcnR5LkVMRU1FTlQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG92ZXJsYXkgaWRlbnRpZmllciB3aGljaCBpcyBzZXQgb24gY29uc3RydWN0b3IuXG4gICAqIEByZXR1cm4ge251bWJlcnxzdHJpbmd8dW5kZWZpbmVkfSBJZC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0SWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtYXAgYXNzb2NpYXRlZCB3aXRoIHRoaXMgb3ZlcmxheS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9NYXAuanNcIikuZGVmYXVsdHxudWxsfSBUaGUgbWFwIHRoYXQgdGhlXG4gICAqIG92ZXJsYXkgaXMgcGFydCBvZi5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TWFwKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge2ltcG9ydChcIi4vTWFwLmpzXCIpLmRlZmF1bHR8bnVsbH0gKi8gKFxuICAgICAgdGhpcy5nZXQoUHJvcGVydHkuTUFQKSB8fCBudWxsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG9mZnNldCBvZiB0aGlzIG92ZXJsYXkuXG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFRoZSBvZmZzZXQuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE9mZnNldCgpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqLyAodGhpcy5nZXQoUHJvcGVydHkuT0ZGU0VUKSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoaXMgb3ZlcmxheS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8dW5kZWZpbmVkfSBUaGUgc3BhdGlhbCBwb2ludCB0aGF0IHRoZSBvdmVybGF5IGlzXG4gICAqICAgICBhbmNob3JlZCBhdC5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0UG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8dW5kZWZpbmVkfSAqLyAoXG4gICAgICB0aGlzLmdldChQcm9wZXJ0eS5QT1NJVElPTilcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBwb3NpdGlvbmluZyBvZiB0aGlzIG92ZXJsYXkuXG4gICAqIEByZXR1cm4ge1Bvc2l0aW9uaW5nfSBIb3cgdGhlIG92ZXJsYXkgaXMgcG9zaXRpb25lZFxuICAgKiAgICAgcmVsYXRpdmUgdG8gaXRzIHBvaW50IG9uIHRoZSBtYXAuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFBvc2l0aW9uaW5nKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge1Bvc2l0aW9uaW5nfSAqLyAodGhpcy5nZXQoUHJvcGVydHkuUE9TSVRJT05JTkcpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBoYW5kbGVFbGVtZW50Q2hhbmdlZCgpIHtcbiAgICByZW1vdmVDaGlsZHJlbih0aGlzLmVsZW1lbnQpO1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmdldEVsZW1lbnQoKTtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBoYW5kbGVNYXBDaGFuZ2VkKCkge1xuICAgIGlmICh0aGlzLm1hcFBvc3RyZW5kZXJMaXN0ZW5lcktleSkge1xuICAgICAgcmVtb3ZlTm9kZSh0aGlzLmVsZW1lbnQpO1xuICAgICAgdW5saXN0ZW5CeUtleSh0aGlzLm1hcFBvc3RyZW5kZXJMaXN0ZW5lcktleSk7XG4gICAgICB0aGlzLm1hcFBvc3RyZW5kZXJMaXN0ZW5lcktleSA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG1hcCA9IHRoaXMuZ2V0TWFwKCk7XG4gICAgaWYgKG1hcCkge1xuICAgICAgdGhpcy5tYXBQb3N0cmVuZGVyTGlzdGVuZXJLZXkgPSBsaXN0ZW4oXG4gICAgICAgIG1hcCxcbiAgICAgICAgTWFwRXZlbnRUeXBlLlBPU1RSRU5ERVIsXG4gICAgICAgIHRoaXMucmVuZGVyLFxuICAgICAgICB0aGlzLFxuICAgICAgKTtcbiAgICAgIHRoaXMudXBkYXRlUGl4ZWxQb3NpdGlvbigpO1xuICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5zdG9wRXZlbnRcbiAgICAgICAgPyBtYXAuZ2V0T3ZlcmxheUNvbnRhaW5lclN0b3BFdmVudCgpXG4gICAgICAgIDogbWFwLmdldE92ZXJsYXlDb250YWluZXIoKTtcbiAgICAgIGlmICh0aGlzLmluc2VydEZpcnN0KSB7XG4gICAgICAgIGNvbnRhaW5lci5pbnNlcnRCZWZvcmUodGhpcy5lbGVtZW50LCBjb250YWluZXIuY2hpbGROb2Rlc1swXSB8fCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgdGhpcy5wZXJmb3JtQXV0b1BhbigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICByZW5kZXIoKSB7XG4gICAgdGhpcy51cGRhdGVQaXhlbFBvc2l0aW9uKCk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgaGFuZGxlT2Zmc2V0Q2hhbmdlZCgpIHtcbiAgICB0aGlzLnVwZGF0ZVBpeGVsUG9zaXRpb24oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBoYW5kbGVQb3NpdGlvbkNoYW5nZWQoKSB7XG4gICAgdGhpcy51cGRhdGVQaXhlbFBvc2l0aW9uKCk7XG4gICAgdGhpcy5wZXJmb3JtQXV0b1BhbigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGhhbmRsZVBvc2l0aW9uaW5nQ2hhbmdlZCgpIHtcbiAgICB0aGlzLnVwZGF0ZVBpeGVsUG9zaXRpb24oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIERPTSBlbGVtZW50IHRvIGJlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG92ZXJsYXkuXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8dW5kZWZpbmVkfSBlbGVtZW50IFRoZSBFbGVtZW50IGNvbnRhaW5pbmcgdGhlIG92ZXJsYXkuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIHNldEVsZW1lbnQoZWxlbWVudCkge1xuICAgIHRoaXMuc2V0KFByb3BlcnR5LkVMRU1FTlQsIGVsZW1lbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgbWFwIHRvIGJlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG92ZXJsYXkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9NYXAuanNcIikuZGVmYXVsdHxudWxsfSBtYXAgVGhlIG1hcCB0aGF0IHRoZVxuICAgKiBvdmVybGF5IGlzIHBhcnQgb2YuIFBhc3MgYG51bGxgIHRvIGp1c3QgcmVtb3ZlIHRoZSBvdmVybGF5IGZyb20gdGhlIGN1cnJlbnQgbWFwLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRNYXAobWFwKSB7XG4gICAgdGhpcy5zZXQoUHJvcGVydHkuTUFQLCBtYXApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgb2Zmc2V0IGZvciB0aGlzIG92ZXJsYXkuXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gb2Zmc2V0IE9mZnNldC5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgc2V0T2Zmc2V0KG9mZnNldCkge1xuICAgIHRoaXMuc2V0KFByb3BlcnR5Lk9GRlNFVCwgb2Zmc2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHBvc2l0aW9uIGZvciB0aGlzIG92ZXJsYXkuIElmIHRoZSBwb3NpdGlvbiBpcyBgdW5kZWZpbmVkYCB0aGVcbiAgICogb3ZlcmxheSBpcyBoaWRkZW4uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8dW5kZWZpbmVkfSBwb3NpdGlvbiBUaGUgc3BhdGlhbCBwb2ludCB0aGF0IHRoZSBvdmVybGF5XG4gICAqICAgICBpcyBhbmNob3JlZCBhdC5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgc2V0UG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICB0aGlzLnNldChQcm9wZXJ0eS5QT1NJVElPTiwgcG9zaXRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhbiB0aGUgbWFwIHNvIHRoYXQgdGhlIG92ZXJsYXkgaXMgZW50aXJlbHkgdmlzaWJsZSBpbiB0aGUgY3VycmVudCB2aWV3cG9ydFxuICAgKiAoaWYgbmVjZXNzYXJ5KSB1c2luZyB0aGUgY29uZmlndXJlZCBhdXRvUGFuIHBhcmFtZXRlcnNcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgcGVyZm9ybUF1dG9QYW4oKSB7XG4gICAgaWYgKHRoaXMuYXV0b1Bhbikge1xuICAgICAgdGhpcy5wYW5JbnRvVmlldyh0aGlzLmF1dG9QYW4pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQYW4gdGhlIG1hcCBzbyB0aGF0IHRoZSBvdmVybGF5IGlzIGVudGlyZWx5IHZpc2libGUgaW4gdGhlIGN1cnJlbnQgdmlld3BvcnRcbiAgICogKGlmIG5lY2Vzc2FyeSkuXG4gICAqIEBwYXJhbSB7UGFuSW50b1ZpZXdPcHRpb25zfSBbcGFuSW50b1ZpZXdPcHRpb25zXSBPcHRpb25zIGZvciB0aGUgcGFuIGFjdGlvblxuICAgKiBAYXBpXG4gICAqL1xuICBwYW5JbnRvVmlldyhwYW5JbnRvVmlld09wdGlvbnMpIHtcbiAgICBjb25zdCBtYXAgPSB0aGlzLmdldE1hcCgpO1xuXG4gICAgaWYgKCFtYXAgfHwgIW1hcC5nZXRUYXJnZXRFbGVtZW50KCkgfHwgIXRoaXMuZ2V0KFByb3BlcnR5LlBPU0lUSU9OKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG1hcFJlY3QgPSB0aGlzLmdldFJlY3QobWFwLmdldFRhcmdldEVsZW1lbnQoKSwgbWFwLmdldFNpemUoKSk7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZ2V0RWxlbWVudCgpO1xuICAgIGNvbnN0IG92ZXJsYXlSZWN0ID0gdGhpcy5nZXRSZWN0KGVsZW1lbnQsIFtcbiAgICAgIG91dGVyV2lkdGgoZWxlbWVudCksXG4gICAgICBvdXRlckhlaWdodChlbGVtZW50KSxcbiAgICBdKTtcblxuICAgIHBhbkludG9WaWV3T3B0aW9ucyA9IHBhbkludG9WaWV3T3B0aW9ucyB8fCB7fTtcblxuICAgIGNvbnN0IG15TWFyZ2luID1cbiAgICAgIHBhbkludG9WaWV3T3B0aW9ucy5tYXJnaW4gPT09IHVuZGVmaW5lZCA/IDIwIDogcGFuSW50b1ZpZXdPcHRpb25zLm1hcmdpbjtcbiAgICBpZiAoIWNvbnRhaW5zRXh0ZW50KG1hcFJlY3QsIG92ZXJsYXlSZWN0KSkge1xuICAgICAgLy8gdGhlIG92ZXJsYXkgaXMgbm90IGNvbXBsZXRlbHkgaW5zaWRlIHRoZSB2aWV3cG9ydCwgc28gcGFuIHRoZSBtYXBcbiAgICAgIGNvbnN0IG9mZnNldExlZnQgPSBvdmVybGF5UmVjdFswXSAtIG1hcFJlY3RbMF07XG4gICAgICBjb25zdCBvZmZzZXRSaWdodCA9IG1hcFJlY3RbMl0gLSBvdmVybGF5UmVjdFsyXTtcbiAgICAgIGNvbnN0IG9mZnNldFRvcCA9IG92ZXJsYXlSZWN0WzFdIC0gbWFwUmVjdFsxXTtcbiAgICAgIGNvbnN0IG9mZnNldEJvdHRvbSA9IG1hcFJlY3RbM10gLSBvdmVybGF5UmVjdFszXTtcblxuICAgICAgY29uc3QgZGVsdGEgPSBbMCwgMF07XG4gICAgICBpZiAob2Zmc2V0TGVmdCA8IDApIHtcbiAgICAgICAgLy8gbW92ZSBtYXAgdG8gdGhlIGxlZnRcbiAgICAgICAgZGVsdGFbMF0gPSBvZmZzZXRMZWZ0IC0gbXlNYXJnaW47XG4gICAgICB9IGVsc2UgaWYgKG9mZnNldFJpZ2h0IDwgMCkge1xuICAgICAgICAvLyBtb3ZlIG1hcCB0byB0aGUgcmlnaHRcbiAgICAgICAgZGVsdGFbMF0gPSBNYXRoLmFicyhvZmZzZXRSaWdodCkgKyBteU1hcmdpbjtcbiAgICAgIH1cbiAgICAgIGlmIChvZmZzZXRUb3AgPCAwKSB7XG4gICAgICAgIC8vIG1vdmUgbWFwIHVwXG4gICAgICAgIGRlbHRhWzFdID0gb2Zmc2V0VG9wIC0gbXlNYXJnaW47XG4gICAgICB9IGVsc2UgaWYgKG9mZnNldEJvdHRvbSA8IDApIHtcbiAgICAgICAgLy8gbW92ZSBtYXAgZG93blxuICAgICAgICBkZWx0YVsxXSA9IE1hdGguYWJzKG9mZnNldEJvdHRvbSkgKyBteU1hcmdpbjtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlbHRhWzBdICE9PSAwIHx8IGRlbHRhWzFdICE9PSAwKSB7XG4gICAgICAgIGNvbnN0IGNlbnRlciA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9ICovIChcbiAgICAgICAgICBtYXAuZ2V0VmlldygpLmdldENlbnRlckludGVybmFsKClcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgY2VudGVyUHggPSBtYXAuZ2V0UGl4ZWxGcm9tQ29vcmRpbmF0ZUludGVybmFsKGNlbnRlcik7XG4gICAgICAgIGlmICghY2VudGVyUHgpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3Q2VudGVyUHggPSBbY2VudGVyUHhbMF0gKyBkZWx0YVswXSwgY2VudGVyUHhbMV0gKyBkZWx0YVsxXV07XG5cbiAgICAgICAgY29uc3QgcGFuT3B0aW9ucyA9IHBhbkludG9WaWV3T3B0aW9ucy5hbmltYXRpb24gfHwge307XG4gICAgICAgIG1hcC5nZXRWaWV3KCkuYW5pbWF0ZUludGVybmFsKHtcbiAgICAgICAgICBjZW50ZXI6IG1hcC5nZXRDb29yZGluYXRlRnJvbVBpeGVsSW50ZXJuYWwobmV3Q2VudGVyUHgpLFxuICAgICAgICAgIGR1cmF0aW9uOiBwYW5PcHRpb25zLmR1cmF0aW9uLFxuICAgICAgICAgIGVhc2luZzogcGFuT3B0aW9ucy5lYXNpbmcsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGV4dGVudCBvZiBhbiBlbGVtZW50IHJlbGF0aXZlIHRvIHRoZSBkb2N1bWVudFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfSBzaXplIFRoZSBzaXplIG9mIHRoZSBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IFRoZSBleHRlbnQuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGdldFJlY3QoZWxlbWVudCwgc2l6ZSkge1xuICAgIGNvbnN0IGJveCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3Qgb2Zmc2V0WCA9IGJveC5sZWZ0ICsgd2luZG93LnBhZ2VYT2Zmc2V0O1xuICAgIGNvbnN0IG9mZnNldFkgPSBib3gudG9wICsgd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgIHJldHVybiBbb2Zmc2V0WCwgb2Zmc2V0WSwgb2Zmc2V0WCArIHNpemVbMF0sIG9mZnNldFkgKyBzaXplWzFdXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHBvc2l0aW9uaW5nIGZvciB0aGlzIG92ZXJsYXkuXG4gICAqIEBwYXJhbSB7UG9zaXRpb25pbmd9IHBvc2l0aW9uaW5nIGhvdyB0aGUgb3ZlcmxheSBpc1xuICAgKiAgICAgcG9zaXRpb25lZCByZWxhdGl2ZSB0byBpdHMgcG9pbnQgb24gdGhlIG1hcC5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgc2V0UG9zaXRpb25pbmcocG9zaXRpb25pbmcpIHtcbiAgICB0aGlzLnNldChQcm9wZXJ0eS5QT1NJVElPTklORywgcG9zaXRpb25pbmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vZGlmeSB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZWxlbWVudC5cbiAgICogQHBhcmFtIHtib29sZWFufSB2aXNpYmxlIEVsZW1lbnQgdmlzaWJpbGl0eS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgc2V0VmlzaWJsZSh2aXNpYmxlKSB7XG4gICAgaWYgKHRoaXMucmVuZGVyZWQudmlzaWJsZSAhPT0gdmlzaWJsZSkge1xuICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSB2aXNpYmxlID8gJycgOiAnbm9uZSc7XG4gICAgICB0aGlzLnJlbmRlcmVkLnZpc2libGUgPSB2aXNpYmxlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgcGl4ZWwgcG9zaXRpb24uXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHVwZGF0ZVBpeGVsUG9zaXRpb24oKSB7XG4gICAgY29uc3QgbWFwID0gdGhpcy5nZXRNYXAoKTtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuZ2V0UG9zaXRpb24oKTtcbiAgICBpZiAoIW1hcCB8fCAhbWFwLmlzUmVuZGVyZWQoKSB8fCAhcG9zaXRpb24pIHtcbiAgICAgIHRoaXMuc2V0VmlzaWJsZShmYWxzZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcGl4ZWwgPSBtYXAuZ2V0UGl4ZWxGcm9tQ29vcmRpbmF0ZShwb3NpdGlvbik7XG4gICAgY29uc3QgbWFwU2l6ZSA9IG1hcC5nZXRTaXplKCk7XG4gICAgdGhpcy51cGRhdGVSZW5kZXJlZFBvc2l0aW9uKHBpeGVsLCBtYXBTaXplKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vcGl4ZWwuanNcIikuUGl4ZWx9IHBpeGVsIFRoZSBwaXhlbCBsb2NhdGlvbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZXx1bmRlZmluZWR9IG1hcFNpemUgVGhlIG1hcCBzaXplLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICB1cGRhdGVSZW5kZXJlZFBvc2l0aW9uKHBpeGVsLCBtYXBTaXplKSB7XG4gICAgY29uc3Qgc3R5bGUgPSB0aGlzLmVsZW1lbnQuc3R5bGU7XG4gICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5nZXRPZmZzZXQoKTtcblxuICAgIGNvbnN0IHBvc2l0aW9uaW5nID0gdGhpcy5nZXRQb3NpdGlvbmluZygpO1xuXG4gICAgdGhpcy5zZXRWaXNpYmxlKHRydWUpO1xuXG4gICAgY29uc3QgeCA9IE1hdGgucm91bmQocGl4ZWxbMF0gKyBvZmZzZXRbMF0pICsgJ3B4JztcbiAgICBjb25zdCB5ID0gTWF0aC5yb3VuZChwaXhlbFsxXSArIG9mZnNldFsxXSkgKyAncHgnO1xuICAgIGxldCBwb3NYID0gJzAlJztcbiAgICBsZXQgcG9zWSA9ICcwJSc7XG4gICAgaWYgKFxuICAgICAgcG9zaXRpb25pbmcgPT0gJ2JvdHRvbS1yaWdodCcgfHxcbiAgICAgIHBvc2l0aW9uaW5nID09ICdjZW50ZXItcmlnaHQnIHx8XG4gICAgICBwb3NpdGlvbmluZyA9PSAndG9wLXJpZ2h0J1xuICAgICkge1xuICAgICAgcG9zWCA9ICctMTAwJSc7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHBvc2l0aW9uaW5nID09ICdib3R0b20tY2VudGVyJyB8fFxuICAgICAgcG9zaXRpb25pbmcgPT0gJ2NlbnRlci1jZW50ZXInIHx8XG4gICAgICBwb3NpdGlvbmluZyA9PSAndG9wLWNlbnRlcidcbiAgICApIHtcbiAgICAgIHBvc1ggPSAnLTUwJSc7XG4gICAgfVxuICAgIGlmIChcbiAgICAgIHBvc2l0aW9uaW5nID09ICdib3R0b20tbGVmdCcgfHxcbiAgICAgIHBvc2l0aW9uaW5nID09ICdib3R0b20tY2VudGVyJyB8fFxuICAgICAgcG9zaXRpb25pbmcgPT0gJ2JvdHRvbS1yaWdodCdcbiAgICApIHtcbiAgICAgIHBvc1kgPSAnLTEwMCUnO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICBwb3NpdGlvbmluZyA9PSAnY2VudGVyLWxlZnQnIHx8XG4gICAgICBwb3NpdGlvbmluZyA9PSAnY2VudGVyLWNlbnRlcicgfHxcbiAgICAgIHBvc2l0aW9uaW5nID09ICdjZW50ZXItcmlnaHQnXG4gICAgKSB7XG4gICAgICBwb3NZID0gJy01MCUnO1xuICAgIH1cbiAgICBjb25zdCB0cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7cG9zWH0sICR7cG9zWX0pIHRyYW5zbGF0ZSgke3h9LCAke3l9KWA7XG4gICAgaWYgKHRoaXMucmVuZGVyZWQudHJhbnNmb3JtXyAhPSB0cmFuc2Zvcm0pIHtcbiAgICAgIHRoaXMucmVuZGVyZWQudHJhbnNmb3JtXyA9IHRyYW5zZm9ybTtcbiAgICAgIHN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogcmV0dXJucyB0aGUgb3B0aW9ucyB0aGlzIE92ZXJsYXkgaGFzIGJlZW4gY3JlYXRlZCB3aXRoXG4gICAqIEByZXR1cm4ge09wdGlvbnN9IG92ZXJsYXkgb3B0aW9uc1xuICAgKi9cbiAgZ2V0T3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE92ZXJsYXk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ol/Overlay.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ol/control.js":
/*!************************************!*\
  !*** ./node_modules/ol/control.js ***!
  \************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Attribution: function() { return /* reexport safe */ _control_Attribution_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; },\n/* harmony export */   Control: function() { return /* reexport safe */ _control_Control_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; },\n/* harmony export */   FullScreen: function() { return /* reexport safe */ _control_FullScreen_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]; },\n/* harmony export */   MousePosition: function() { return /* reexport safe */ _control_MousePosition_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]; },\n/* harmony export */   OverviewMap: function() { return /* reexport safe */ _control_OverviewMap_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]; },\n/* harmony export */   Rotate: function() { return /* reexport safe */ _control_Rotate_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]; },\n/* harmony export */   ScaleLine: function() { return /* reexport safe */ _control_ScaleLine_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]; },\n/* harmony export */   Zoom: function() { return /* reexport safe */ _control_Zoom_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]; },\n/* harmony export */   ZoomSlider: function() { return /* reexport safe */ _control_ZoomSlider_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"]; },\n/* harmony export */   ZoomToExtent: function() { return /* reexport safe */ _control_ZoomToExtent_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"]; },\n/* harmony export */   defaults: function() { return /* reexport safe */ _control_defaults_js__WEBPACK_IMPORTED_MODULE_10__.defaults; }\n/* harmony export */ });\n/* harmony import */ var _control_Attribution_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./control/Attribution.js */ \"(app-pages-browser)/./node_modules/ol/control/Attribution.js\");\n/* harmony import */ var _control_Control_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./control/Control.js */ \"(app-pages-browser)/./node_modules/ol/control/Control.js\");\n/* harmony import */ var _control_FullScreen_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./control/FullScreen.js */ \"(app-pages-browser)/./node_modules/ol/control/FullScreen.js\");\n/* harmony import */ var _control_MousePosition_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./control/MousePosition.js */ \"(app-pages-browser)/./node_modules/ol/control/MousePosition.js\");\n/* harmony import */ var _control_OverviewMap_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./control/OverviewMap.js */ \"(app-pages-browser)/./node_modules/ol/control/OverviewMap.js\");\n/* harmony import */ var _control_Rotate_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./control/Rotate.js */ \"(app-pages-browser)/./node_modules/ol/control/Rotate.js\");\n/* harmony import */ var _control_ScaleLine_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./control/ScaleLine.js */ \"(app-pages-browser)/./node_modules/ol/control/ScaleLine.js\");\n/* harmony import */ var _control_Zoom_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./control/Zoom.js */ \"(app-pages-browser)/./node_modules/ol/control/Zoom.js\");\n/* harmony import */ var _control_ZoomSlider_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./control/ZoomSlider.js */ \"(app-pages-browser)/./node_modules/ol/control/ZoomSlider.js\");\n/* harmony import */ var _control_ZoomToExtent_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./control/ZoomToExtent.js */ \"(app-pages-browser)/./node_modules/ol/control/ZoomToExtent.js\");\n/* harmony import */ var _control_defaults_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./control/defaults.js */ \"(app-pages-browser)/./node_modules/ol/control/defaults.js\");\n/**\n * @module ol/control\n */\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vbC9jb250cm9sLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDZ0U7QUFDUjtBQUNNO0FBQ007QUFDSjtBQUNWO0FBQ007QUFDVjtBQUNZO0FBQ0k7QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL29sL2NvbnRyb2wuanM/NzFjZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvY29udHJvbFxuICovXG5leHBvcnQge2RlZmF1bHQgYXMgQXR0cmlidXRpb259IGZyb20gJy4vY29udHJvbC9BdHRyaWJ1dGlvbi5qcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgQ29udHJvbH0gZnJvbSAnLi9jb250cm9sL0NvbnRyb2wuanMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIEZ1bGxTY3JlZW59IGZyb20gJy4vY29udHJvbC9GdWxsU2NyZWVuLmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBNb3VzZVBvc2l0aW9ufSBmcm9tICcuL2NvbnRyb2wvTW91c2VQb3NpdGlvbi5qcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgT3ZlcnZpZXdNYXB9IGZyb20gJy4vY29udHJvbC9PdmVydmlld01hcC5qcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgUm90YXRlfSBmcm9tICcuL2NvbnRyb2wvUm90YXRlLmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBTY2FsZUxpbmV9IGZyb20gJy4vY29udHJvbC9TY2FsZUxpbmUuanMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIFpvb219IGZyb20gJy4vY29udHJvbC9ab29tLmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBab29tU2xpZGVyfSBmcm9tICcuL2NvbnRyb2wvWm9vbVNsaWRlci5qcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgWm9vbVRvRXh0ZW50fSBmcm9tICcuL2NvbnRyb2wvWm9vbVRvRXh0ZW50LmpzJztcbmV4cG9ydCB7ZGVmYXVsdHN9IGZyb20gJy4vY29udHJvbC9kZWZhdWx0cy5qcyc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ol/control.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ol/control/MousePosition.js":
/*!**************************************************!*\
  !*** ./node_modules/ol/control/MousePosition.js ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Control_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Control.js */ \"(app-pages-browser)/./node_modules/ol/control/Control.js\");\n/* harmony import */ var _pointer_EventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../pointer/EventType.js */ \"(app-pages-browser)/./node_modules/ol/pointer/EventType.js\");\n/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ \"(app-pages-browser)/./node_modules/ol/proj.js\");\n/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events.js */ \"(app-pages-browser)/./node_modules/ol/events.js\");\n/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../coordinate.js */ \"(app-pages-browser)/./node_modules/ol/coordinate.js\");\n/**\n * @module ol/control/MousePosition\n */\n\n\n\n\n\n\n\n/**\n * @type {string}\n */\nconst PROJECTION = 'projection';\n\n/**\n * @type {string}\n */\nconst COORDINATE_FORMAT = 'coordinateFormat';\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:coordinateFormat'|'change:projection', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:coordinateFormat'|'change:projection', Return>} MousePositionOnSignature\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-mouse-position'] CSS class name.\n * @property {import(\"../coordinate.js\").CoordinateFormat} [coordinateFormat] Coordinate format.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is the view projection.\n * @property {function(import(\"../MapEvent.js\").default):void} [render] Function called when the\n * control should be re-rendered. This is called in a `requestAnimationFrame`\n * callback.\n * @property {HTMLElement|string} [target] Specify a target if you want the\n * control to be rendered outside of the map's viewport.\n * @property {string} [placeholder] Markup to show when the mouse position is not\n * available (e.g. when the pointer leaves the map viewport).  By default, a non-breaking space is rendered\n * initially and the last position is retained when the mouse leaves the viewport.\n * When a string is provided (e.g. `'no position'` or `''` for an empty string) it is used as a\n * placeholder.\n * @property {boolean} [wrapX=true] Wrap the world horizontally on the projection's antimeridian, if it\n * is a global projection.\n */\n\n/**\n * @classdesc\n * A control to show the 2D coordinates of the mouse cursor. By default, these\n * are in the view projection, but can be in any supported projection.\n * By default the control is shown in the top right corner of the map, but this\n * can be changed by using the css selector `.ol-mouse-position`.\n *\n * On touch devices, which usually do not have a mouse cursor, the coordinates\n * of the currently touched position are shown.\n *\n * @api\n */\nclass MousePosition extends _Control_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n  /**\n   * @param {Options} [options] Mouse position options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const element = document.createElement('div');\n    element.className =\n      options.className !== undefined ? options.className : 'ol-mouse-position';\n\n    super({\n      element: element,\n      render: options.render,\n      target: options.target,\n    });\n\n    /***\n     * @type {MousePositionOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {MousePositionOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {MousePositionOnSignature<void>}\n     */\n    this.un;\n\n    this.addChangeListener(PROJECTION, this.handleProjectionChanged_);\n\n    if (options.coordinateFormat) {\n      this.setCoordinateFormat(options.coordinateFormat);\n    }\n    if (options.projection) {\n      this.setProjection(options.projection);\n    }\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderOnMouseOut_ = options.placeholder !== undefined;\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.placeholder_ = this.renderOnMouseOut_ ? options.placeholder : '&#160;';\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.renderedHTML_ = element.innerHTML;\n\n    /**\n     * @private\n     * @type {?import(\"../proj/Projection.js\").default}\n     */\n    this.mapProjection_ = null;\n\n    /**\n     * @private\n     * @type {?import(\"../proj.js\").TransformFunction}\n     */\n    this.transform_ = null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.wrapX_ = options.wrapX === false ? false : true;\n  }\n\n  /**\n   * @private\n   */\n  handleProjectionChanged_() {\n    this.transform_ = null;\n  }\n\n  /**\n   * Return the coordinate format type used to render the current position or\n   * undefined.\n   * @return {import(\"../coordinate.js\").CoordinateFormat|undefined} The format to render the current\n   *     position in.\n   * @observable\n   * @api\n   */\n  getCoordinateFormat() {\n    return /** @type {import(\"../coordinate.js\").CoordinateFormat|undefined} */ (\n      this.get(COORDINATE_FORMAT)\n    );\n  }\n\n  /**\n   * Return the projection that is used to report the mouse position.\n   * @return {import(\"../proj/Projection.js\").default|undefined} The projection to report mouse\n   *     position in.\n   * @observable\n   * @api\n   */\n  getProjection() {\n    return /** @type {import(\"../proj/Projection.js\").default|undefined} */ (\n      this.get(PROJECTION)\n    );\n  }\n\n  /**\n   * @param {MouseEvent} event Browser event.\n   * @protected\n   */\n  handleMouseMove(event) {\n    const map = this.getMap();\n    this.updateHTML_(map.getEventPixel(event));\n  }\n\n  /**\n   * @param {Event} event Browser event.\n   * @protected\n   */\n  handleMouseOut(event) {\n    this.updateHTML_(null);\n  }\n\n  /**\n   * Remove the control from its current map and attach it to the new map.\n   * Pass `null` to just remove the control from the current map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default|null} map Map.\n   * @api\n   */\n  setMap(map) {\n    super.setMap(map);\n    if (map) {\n      const viewport = map.getViewport();\n      this.listenerKeys.push(\n        (0,_events_js__WEBPACK_IMPORTED_MODULE_2__.listen)(viewport, _pointer_EventType_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].POINTERMOVE, this.handleMouseMove, this),\n      );\n      if (this.renderOnMouseOut_) {\n        this.listenerKeys.push(\n          (0,_events_js__WEBPACK_IMPORTED_MODULE_2__.listen)(viewport, _pointer_EventType_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].POINTEROUT, this.handleMouseOut, this),\n        );\n      }\n      this.updateHTML_(null);\n    }\n  }\n\n  /**\n   * Set the coordinate format type used to render the current position.\n   * @param {import(\"../coordinate.js\").CoordinateFormat} format The format to render the current\n   *     position in.\n   * @observable\n   * @api\n   */\n  setCoordinateFormat(format) {\n    this.set(COORDINATE_FORMAT, format);\n  }\n\n  /**\n   * Set the projection that is used to report the mouse position.\n   * @param {import(\"../proj.js\").ProjectionLike} projection The projection to report mouse\n   *     position in.\n   * @observable\n   * @api\n   */\n  setProjection(projection) {\n    this.set(PROJECTION, (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(projection));\n  }\n\n  /**\n   * @param {?import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @private\n   */\n  updateHTML_(pixel) {\n    let html = this.placeholder_;\n    if (pixel && this.mapProjection_) {\n      if (!this.transform_) {\n        const projection = this.getProjection();\n        if (projection) {\n          this.transform_ = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getTransformFromProjections)(\n            this.mapProjection_,\n            projection,\n          );\n        } else {\n          this.transform_ = _proj_js__WEBPACK_IMPORTED_MODULE_0__.identityTransform;\n        }\n      }\n      const map = this.getMap();\n      const coordinate = map.getCoordinateFromPixelInternal(pixel);\n      if (coordinate) {\n        const userProjection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getUserProjection)();\n        if (userProjection) {\n          this.transform_ = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getTransformFromProjections)(\n            this.mapProjection_,\n            userProjection,\n          );\n        }\n        this.transform_(coordinate, coordinate);\n        if (this.wrapX_) {\n          const projection =\n            userProjection || this.getProjection() || this.mapProjection_;\n          (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_4__.wrapX)(coordinate, projection);\n        }\n        const coordinateFormat = this.getCoordinateFormat();\n        if (coordinateFormat) {\n          html = coordinateFormat(coordinate);\n        } else {\n          html = coordinate.toString();\n        }\n      }\n    }\n    if (!this.renderedHTML_ || html !== this.renderedHTML_) {\n      this.element.innerHTML = html;\n      this.renderedHTML_ = html;\n    }\n  }\n\n  /**\n   * Update the projection. Rendering of the coordinates is done in\n   * `handleMouseMove` and `handleMouseUp`.\n   * @param {import(\"../MapEvent.js\").default} mapEvent Map event.\n   * @override\n   */\n  render(mapEvent) {\n    const frameState = mapEvent.frameState;\n    if (!frameState) {\n      this.mapProjection_ = null;\n    } else {\n      if (this.mapProjection_ != frameState.viewState.projection) {\n        this.mapProjection_ = frameState.viewState.projection;\n        this.transform_ = null;\n      }\n    }\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (MousePosition);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vbC9jb250cm9sL01vdXNlUG9zaXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBOztBQUVtQztBQUNhO0FBTTVCO0FBQ2dCO0FBQ0c7O0FBRXZDO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEIsY0FBYyw2Q0FBNkM7QUFDM0QsY0FBYyxxQ0FBcUM7QUFDbkQsY0FBYyxpREFBaUQ7QUFDL0Q7QUFDQTtBQUNBLGNBQWMsb0JBQW9CO0FBQ2xDO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1EQUFPO0FBQ25DO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLDhFQUE4RTs7QUFFOUU7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdURBQXVEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdURBQXVEO0FBQzdFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxtREFBbUQ7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtREFBbUQ7QUFDekU7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtDQUFrQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU0sV0FBVyw2REFBUztBQUNsQztBQUNBO0FBQ0E7QUFDQSxVQUFVLGtEQUFNLFdBQVcsNkRBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSw2Q0FBNkM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEscUNBQXFDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNkNBQWE7QUFDdEM7O0FBRUE7QUFDQSxhQUFhLDhCQUE4QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFFQUEyQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsNEJBQTRCLHVEQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDJEQUFpQjtBQUNoRDtBQUNBLDRCQUE0QixxRUFBMkI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUscURBQUs7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrQ0FBa0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtEQUFlLGFBQWEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvb2wvY29udHJvbC9Nb3VzZVBvc2l0aW9uLmpzP2Q0MmQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIG9sL2NvbnRyb2wvTW91c2VQb3NpdGlvblxuICovXG5cbmltcG9ydCBDb250cm9sIGZyb20gJy4vQ29udHJvbC5qcyc7XG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4uL3BvaW50ZXIvRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7XG4gIGdldCBhcyBnZXRQcm9qZWN0aW9uLFxuICBnZXRUcmFuc2Zvcm1Gcm9tUHJvamVjdGlvbnMsXG4gIGdldFVzZXJQcm9qZWN0aW9uLFxuICBpZGVudGl0eVRyYW5zZm9ybSxcbn0gZnJvbSAnLi4vcHJvai5qcyc7XG5pbXBvcnQge2xpc3Rlbn0gZnJvbSAnLi4vZXZlbnRzLmpzJztcbmltcG9ydCB7d3JhcFh9IGZyb20gJy4uL2Nvb3JkaW5hdGUuanMnO1xuXG4vKipcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmNvbnN0IFBST0pFQ1RJT04gPSAncHJvamVjdGlvbic7XG5cbi8qKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuY29uc3QgQ09PUkRJTkFURV9GT1JNQVQgPSAnY29vcmRpbmF0ZUZvcm1hdCc7XG5cbi8qKipcbiAqIEB0ZW1wbGF0ZSBSZXR1cm5cbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPGltcG9ydChcIi4uL09ic2VydmFibGVcIikuRXZlbnRUeXBlcywgaW1wb3J0KFwiLi4vZXZlbnRzL0V2ZW50LmpzXCIpLmRlZmF1bHQsIFJldHVybj4gJlxuICogICBpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPGltcG9ydChcIi4uL09iamVjdEV2ZW50VHlwZVwiKS5UeXBlc3xcbiAqICAgICAnY2hhbmdlOmNvb3JkaW5hdGVGb3JtYXQnfCdjaGFuZ2U6cHJvamVjdGlvbicsIGltcG9ydChcIi4uL09iamVjdFwiKS5PYmplY3RFdmVudCwgUmV0dXJuPiAmXG4gKiAgIGltcG9ydChcIi4uL09ic2VydmFibGVcIikuQ29tYmluZWRPblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLkV2ZW50VHlwZXN8aW1wb3J0KFwiLi4vT2JqZWN0RXZlbnRUeXBlXCIpLlR5cGVzfFxuICogICAgICdjaGFuZ2U6Y29vcmRpbmF0ZUZvcm1hdCd8J2NoYW5nZTpwcm9qZWN0aW9uJywgUmV0dXJuPn0gTW91c2VQb3NpdGlvbk9uU2lnbmF0dXJlXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzTmFtZT0nb2wtbW91c2UtcG9zaXRpb24nXSBDU1MgY2xhc3MgbmFtZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlRm9ybWF0fSBbY29vcmRpbmF0ZUZvcm1hdF0gQ29vcmRpbmF0ZSBmb3JtYXQuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3Byb2ouanNcIikuUHJvamVjdGlvbkxpa2V9IFtwcm9qZWN0aW9uXSBQcm9qZWN0aW9uLiBEZWZhdWx0IGlzIHRoZSB2aWV3IHByb2plY3Rpb24uXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKGltcG9ydChcIi4uL01hcEV2ZW50LmpzXCIpLmRlZmF1bHQpOnZvaWR9IFtyZW5kZXJdIEZ1bmN0aW9uIGNhbGxlZCB3aGVuIHRoZVxuICogY29udHJvbCBzaG91bGQgYmUgcmUtcmVuZGVyZWQuIFRoaXMgaXMgY2FsbGVkIGluIGEgYHJlcXVlc3RBbmltYXRpb25GcmFtZWBcbiAqIGNhbGxiYWNrLlxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudHxzdHJpbmd9IFt0YXJnZXRdIFNwZWNpZnkgYSB0YXJnZXQgaWYgeW91IHdhbnQgdGhlXG4gKiBjb250cm9sIHRvIGJlIHJlbmRlcmVkIG91dHNpZGUgb2YgdGhlIG1hcCdzIHZpZXdwb3J0LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtwbGFjZWhvbGRlcl0gTWFya3VwIHRvIHNob3cgd2hlbiB0aGUgbW91c2UgcG9zaXRpb24gaXMgbm90XG4gKiBhdmFpbGFibGUgKGUuZy4gd2hlbiB0aGUgcG9pbnRlciBsZWF2ZXMgdGhlIG1hcCB2aWV3cG9ydCkuICBCeSBkZWZhdWx0LCBhIG5vbi1icmVha2luZyBzcGFjZSBpcyByZW5kZXJlZFxuICogaW5pdGlhbGx5IGFuZCB0aGUgbGFzdCBwb3NpdGlvbiBpcyByZXRhaW5lZCB3aGVuIHRoZSBtb3VzZSBsZWF2ZXMgdGhlIHZpZXdwb3J0LlxuICogV2hlbiBhIHN0cmluZyBpcyBwcm92aWRlZCAoZS5nLiBgJ25vIHBvc2l0aW9uJ2Agb3IgYCcnYCBmb3IgYW4gZW1wdHkgc3RyaW5nKSBpdCBpcyB1c2VkIGFzIGFcbiAqIHBsYWNlaG9sZGVyLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbd3JhcFg9dHJ1ZV0gV3JhcCB0aGUgd29ybGQgaG9yaXpvbnRhbGx5IG9uIHRoZSBwcm9qZWN0aW9uJ3MgYW50aW1lcmlkaWFuLCBpZiBpdFxuICogaXMgYSBnbG9iYWwgcHJvamVjdGlvbi5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEEgY29udHJvbCB0byBzaG93IHRoZSAyRCBjb29yZGluYXRlcyBvZiB0aGUgbW91c2UgY3Vyc29yLiBCeSBkZWZhdWx0LCB0aGVzZVxuICogYXJlIGluIHRoZSB2aWV3IHByb2plY3Rpb24sIGJ1dCBjYW4gYmUgaW4gYW55IHN1cHBvcnRlZCBwcm9qZWN0aW9uLlxuICogQnkgZGVmYXVsdCB0aGUgY29udHJvbCBpcyBzaG93biBpbiB0aGUgdG9wIHJpZ2h0IGNvcm5lciBvZiB0aGUgbWFwLCBidXQgdGhpc1xuICogY2FuIGJlIGNoYW5nZWQgYnkgdXNpbmcgdGhlIGNzcyBzZWxlY3RvciBgLm9sLW1vdXNlLXBvc2l0aW9uYC5cbiAqXG4gKiBPbiB0b3VjaCBkZXZpY2VzLCB3aGljaCB1c3VhbGx5IGRvIG5vdCBoYXZlIGEgbW91c2UgY3Vyc29yLCB0aGUgY29vcmRpbmF0ZXNcbiAqIG9mIHRoZSBjdXJyZW50bHkgdG91Y2hlZCBwb3NpdGlvbiBhcmUgc2hvd24uXG4gKlxuICogQGFwaVxuICovXG5jbGFzcyBNb3VzZVBvc2l0aW9uIGV4dGVuZHMgQ29udHJvbCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSBNb3VzZSBwb3NpdGlvbiBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zID8gb3B0aW9ucyA6IHt9O1xuXG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGVsZW1lbnQuY2xhc3NOYW1lID1cbiAgICAgIG9wdGlvbnMuY2xhc3NOYW1lICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNsYXNzTmFtZSA6ICdvbC1tb3VzZS1wb3NpdGlvbic7XG5cbiAgICBzdXBlcih7XG4gICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgcmVuZGVyOiBvcHRpb25zLnJlbmRlcixcbiAgICAgIHRhcmdldDogb3B0aW9ucy50YXJnZXQsXG4gICAgfSk7XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge01vdXNlUG9zaXRpb25PblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9ldmVudHNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLm9uO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtNb3VzZVBvc2l0aW9uT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vZXZlbnRzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5vbmNlO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtNb3VzZVBvc2l0aW9uT25TaWduYXR1cmU8dm9pZD59XG4gICAgICovXG4gICAgdGhpcy51bjtcblxuICAgIHRoaXMuYWRkQ2hhbmdlTGlzdGVuZXIoUFJPSkVDVElPTiwgdGhpcy5oYW5kbGVQcm9qZWN0aW9uQ2hhbmdlZF8pO1xuXG4gICAgaWYgKG9wdGlvbnMuY29vcmRpbmF0ZUZvcm1hdCkge1xuICAgICAgdGhpcy5zZXRDb29yZGluYXRlRm9ybWF0KG9wdGlvbnMuY29vcmRpbmF0ZUZvcm1hdCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnByb2plY3Rpb24pIHtcbiAgICAgIHRoaXMuc2V0UHJvamVjdGlvbihvcHRpb25zLnByb2plY3Rpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJPbk1vdXNlT3V0XyA9IG9wdGlvbnMucGxhY2Vob2xkZXIgIT09IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnBsYWNlaG9sZGVyXyA9IHRoaXMucmVuZGVyT25Nb3VzZU91dF8gPyBvcHRpb25zLnBsYWNlaG9sZGVyIDogJyYjMTYwOyc7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZEhUTUxfID0gZWxlbWVudC5pbm5lckhUTUw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy5tYXBQcm9qZWN0aW9uXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5UcmFuc2Zvcm1GdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLnRyYW5zZm9ybV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLndyYXBYXyA9IG9wdGlvbnMud3JhcFggPT09IGZhbHNlID8gZmFsc2UgOiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVQcm9qZWN0aW9uQ2hhbmdlZF8oKSB7XG4gICAgdGhpcy50cmFuc2Zvcm1fID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGNvb3JkaW5hdGUgZm9ybWF0IHR5cGUgdXNlZCB0byByZW5kZXIgdGhlIGN1cnJlbnQgcG9zaXRpb24gb3JcbiAgICogdW5kZWZpbmVkLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGVGb3JtYXR8dW5kZWZpbmVkfSBUaGUgZm9ybWF0IHRvIHJlbmRlciB0aGUgY3VycmVudFxuICAgKiAgICAgcG9zaXRpb24gaW4uXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIGdldENvb3JkaW5hdGVGb3JtYXQoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlRm9ybWF0fHVuZGVmaW5lZH0gKi8gKFxuICAgICAgdGhpcy5nZXQoQ09PUkRJTkFURV9GT1JNQVQpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHByb2plY3Rpb24gdGhhdCBpcyB1c2VkIHRvIHJlcG9ydCB0aGUgbW91c2UgcG9zaXRpb24uXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fHVuZGVmaW5lZH0gVGhlIHByb2plY3Rpb24gdG8gcmVwb3J0IG1vdXNlXG4gICAqICAgICBwb3NpdGlvbiBpbi5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0UHJvamVjdGlvbigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdHx1bmRlZmluZWR9ICovIChcbiAgICAgIHRoaXMuZ2V0KFBST0pFQ1RJT04pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50IEJyb3dzZXIgZXZlbnQuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGhhbmRsZU1vdXNlTW92ZShldmVudCkge1xuICAgIGNvbnN0IG1hcCA9IHRoaXMuZ2V0TWFwKCk7XG4gICAgdGhpcy51cGRhdGVIVE1MXyhtYXAuZ2V0RXZlbnRQaXhlbChldmVudCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IEJyb3dzZXIgZXZlbnQuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGhhbmRsZU1vdXNlT3V0KGV2ZW50KSB7XG4gICAgdGhpcy51cGRhdGVIVE1MXyhudWxsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGNvbnRyb2wgZnJvbSBpdHMgY3VycmVudCBtYXAgYW5kIGF0dGFjaCBpdCB0byB0aGUgbmV3IG1hcC5cbiAgICogUGFzcyBgbnVsbGAgdG8ganVzdCByZW1vdmUgdGhlIGNvbnRyb2wgZnJvbSB0aGUgY3VycmVudCBtYXAuXG4gICAqIFN1YmNsYXNzZXMgbWF5IHNldCB1cCBldmVudCBoYW5kbGVycyB0byBnZXQgbm90aWZpZWQgYWJvdXQgY2hhbmdlcyB0b1xuICAgKiB0aGUgbWFwIGhlcmUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLmRlZmF1bHR8bnVsbH0gbWFwIE1hcC5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0TWFwKG1hcCkge1xuICAgIHN1cGVyLnNldE1hcChtYXApO1xuICAgIGlmIChtYXApIHtcbiAgICAgIGNvbnN0IHZpZXdwb3J0ID0gbWFwLmdldFZpZXdwb3J0KCk7XG4gICAgICB0aGlzLmxpc3RlbmVyS2V5cy5wdXNoKFxuICAgICAgICBsaXN0ZW4odmlld3BvcnQsIEV2ZW50VHlwZS5QT0lOVEVSTU9WRSwgdGhpcy5oYW5kbGVNb3VzZU1vdmUsIHRoaXMpLFxuICAgICAgKTtcbiAgICAgIGlmICh0aGlzLnJlbmRlck9uTW91c2VPdXRfKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJLZXlzLnB1c2goXG4gICAgICAgICAgbGlzdGVuKHZpZXdwb3J0LCBFdmVudFR5cGUuUE9JTlRFUk9VVCwgdGhpcy5oYW5kbGVNb3VzZU91dCwgdGhpcyksXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZUhUTUxfKG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNvb3JkaW5hdGUgZm9ybWF0IHR5cGUgdXNlZCB0byByZW5kZXIgdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlRm9ybWF0fSBmb3JtYXQgVGhlIGZvcm1hdCB0byByZW5kZXIgdGhlIGN1cnJlbnRcbiAgICogICAgIHBvc2l0aW9uIGluLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRDb29yZGluYXRlRm9ybWF0KGZvcm1hdCkge1xuICAgIHRoaXMuc2V0KENPT1JESU5BVEVfRk9STUFULCBmb3JtYXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgcHJvamVjdGlvbiB0aGF0IGlzIHVzZWQgdG8gcmVwb3J0IHRoZSBtb3VzZSBwb3NpdGlvbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qLmpzXCIpLlByb2plY3Rpb25MaWtlfSBwcm9qZWN0aW9uIFRoZSBwcm9qZWN0aW9uIHRvIHJlcG9ydCBtb3VzZVxuICAgKiAgICAgcG9zaXRpb24gaW4uXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFByb2plY3Rpb24ocHJvamVjdGlvbikge1xuICAgIHRoaXMuc2V0KFBST0pFQ1RJT04sIGdldFByb2plY3Rpb24ocHJvamVjdGlvbikpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7P2ltcG9ydChcIi4uL3BpeGVsLmpzXCIpLlBpeGVsfSBwaXhlbCBQaXhlbC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHVwZGF0ZUhUTUxfKHBpeGVsKSB7XG4gICAgbGV0IGh0bWwgPSB0aGlzLnBsYWNlaG9sZGVyXztcbiAgICBpZiAocGl4ZWwgJiYgdGhpcy5tYXBQcm9qZWN0aW9uXykge1xuICAgICAgaWYgKCF0aGlzLnRyYW5zZm9ybV8pIHtcbiAgICAgICAgY29uc3QgcHJvamVjdGlvbiA9IHRoaXMuZ2V0UHJvamVjdGlvbigpO1xuICAgICAgICBpZiAocHJvamVjdGlvbikge1xuICAgICAgICAgIHRoaXMudHJhbnNmb3JtXyA9IGdldFRyYW5zZm9ybUZyb21Qcm9qZWN0aW9ucyhcbiAgICAgICAgICAgIHRoaXMubWFwUHJvamVjdGlvbl8sXG4gICAgICAgICAgICBwcm9qZWN0aW9uLFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy50cmFuc2Zvcm1fID0gaWRlbnRpdHlUcmFuc2Zvcm07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IG1hcCA9IHRoaXMuZ2V0TWFwKCk7XG4gICAgICBjb25zdCBjb29yZGluYXRlID0gbWFwLmdldENvb3JkaW5hdGVGcm9tUGl4ZWxJbnRlcm5hbChwaXhlbCk7XG4gICAgICBpZiAoY29vcmRpbmF0ZSkge1xuICAgICAgICBjb25zdCB1c2VyUHJvamVjdGlvbiA9IGdldFVzZXJQcm9qZWN0aW9uKCk7XG4gICAgICAgIGlmICh1c2VyUHJvamVjdGlvbikge1xuICAgICAgICAgIHRoaXMudHJhbnNmb3JtXyA9IGdldFRyYW5zZm9ybUZyb21Qcm9qZWN0aW9ucyhcbiAgICAgICAgICAgIHRoaXMubWFwUHJvamVjdGlvbl8sXG4gICAgICAgICAgICB1c2VyUHJvamVjdGlvbixcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhbnNmb3JtXyhjb29yZGluYXRlLCBjb29yZGluYXRlKTtcbiAgICAgICAgaWYgKHRoaXMud3JhcFhfKSB7XG4gICAgICAgICAgY29uc3QgcHJvamVjdGlvbiA9XG4gICAgICAgICAgICB1c2VyUHJvamVjdGlvbiB8fCB0aGlzLmdldFByb2plY3Rpb24oKSB8fCB0aGlzLm1hcFByb2plY3Rpb25fO1xuICAgICAgICAgIHdyYXBYKGNvb3JkaW5hdGUsIHByb2plY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvb3JkaW5hdGVGb3JtYXQgPSB0aGlzLmdldENvb3JkaW5hdGVGb3JtYXQoKTtcbiAgICAgICAgaWYgKGNvb3JkaW5hdGVGb3JtYXQpIHtcbiAgICAgICAgICBodG1sID0gY29vcmRpbmF0ZUZvcm1hdChjb29yZGluYXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBodG1sID0gY29vcmRpbmF0ZS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy5yZW5kZXJlZEhUTUxfIHx8IGh0bWwgIT09IHRoaXMucmVuZGVyZWRIVE1MXykge1xuICAgICAgdGhpcy5lbGVtZW50LmlubmVySFRNTCA9IGh0bWw7XG4gICAgICB0aGlzLnJlbmRlcmVkSFRNTF8gPSBodG1sO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHByb2plY3Rpb24uIFJlbmRlcmluZyBvZiB0aGUgY29vcmRpbmF0ZXMgaXMgZG9uZSBpblxuICAgKiBgaGFuZGxlTW91c2VNb3ZlYCBhbmQgYGhhbmRsZU1vdXNlVXBgLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEV2ZW50IE1hcCBldmVudC5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICByZW5kZXIobWFwRXZlbnQpIHtcbiAgICBjb25zdCBmcmFtZVN0YXRlID0gbWFwRXZlbnQuZnJhbWVTdGF0ZTtcbiAgICBpZiAoIWZyYW1lU3RhdGUpIHtcbiAgICAgIHRoaXMubWFwUHJvamVjdGlvbl8gPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5tYXBQcm9qZWN0aW9uXyAhPSBmcmFtZVN0YXRlLnZpZXdTdGF0ZS5wcm9qZWN0aW9uKSB7XG4gICAgICAgIHRoaXMubWFwUHJvamVjdGlvbl8gPSBmcmFtZVN0YXRlLnZpZXdTdGF0ZS5wcm9qZWN0aW9uO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybV8gPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNb3VzZVBvc2l0aW9uO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ol/control/MousePosition.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ol/control/OverviewMap.js":
/*!************************************************!*\
  !*** ./node_modules/ol/control/OverviewMap.js ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Collection.js */ \"(app-pages-browser)/./node_modules/ol/Collection.js\");\n/* harmony import */ var _Control_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Control.js */ \"(app-pages-browser)/./node_modules/ol/control/Control.js\");\n/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/EventType.js */ \"(app-pages-browser)/./node_modules/ol/events/EventType.js\");\n/* harmony import */ var _Map_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Map.js */ \"(app-pages-browser)/./node_modules/ol/Map.js\");\n/* harmony import */ var _MapEventType_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../MapEventType.js */ \"(app-pages-browser)/./node_modules/ol/MapEventType.js\");\n/* harmony import */ var _MapProperty_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../MapProperty.js */ \"(app-pages-browser)/./node_modules/ol/MapProperty.js\");\n/* harmony import */ var _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../ObjectEventType.js */ \"(app-pages-browser)/./node_modules/ol/ObjectEventType.js\");\n/* harmony import */ var _Overlay_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Overlay.js */ \"(app-pages-browser)/./node_modules/ol/Overlay.js\");\n/* harmony import */ var _View_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../View.js */ \"(app-pages-browser)/./node_modules/ol/View.js\");\n/* harmony import */ var _ViewProperty_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../ViewProperty.js */ \"(app-pages-browser)/./node_modules/ol/ViewProperty.js\");\n/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../css.js */ \"(app-pages-browser)/./node_modules/ol/css.js\");\n/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../extent.js */ \"(app-pages-browser)/./node_modules/ol/extent.js\");\n/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../events.js */ \"(app-pages-browser)/./node_modules/ol/events.js\");\n/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../geom/Polygon.js */ \"(app-pages-browser)/./node_modules/ol/geom/Polygon.js\");\n/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../dom.js */ \"(app-pages-browser)/./node_modules/ol/dom.js\");\n/**\n * @module ol/control/OverviewMap\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Maximum width and/or height extent ratio that determines when the overview\n * map should be zoomed out.\n * @type {number}\n */\nconst MAX_RATIO = 0.75;\n\n/**\n * Minimum width and/or height extent ratio that determines when the overview\n * map should be zoomed in.\n * @type {number}\n */\nconst MIN_RATIO = 0.1;\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-overviewmap'] CSS class name.\n * @property {boolean} [collapsed=true] Whether the control should start collapsed or not (expanded).\n * @property {string|HTMLElement} [collapseLabel=''] Text label to use for the\n * expanded overviewmap button. Instead of text, also an element (e.g. a `span` element) can be used.\n * @property {boolean} [collapsible=true] Whether the control can be collapsed or not.\n * @property {string|HTMLElement} [label=''] Text label to use for the collapsed\n * overviewmap button. Instead of text, also an element (e.g. a `span` element) can be used.\n * @property {Array<import(\"../layer/Base.js\").default>|import(\"../Collection.js\").default<import(\"../layer/Base.js\").default>} [layers]\n * Layers for the overview map.\n * @property {function(import(\"../MapEvent.js\").default):void} [render] Function called when the control\n * should be re-rendered. This is called in a `requestAnimationFrame` callback.\n * @property {boolean} [rotateWithView=false] Whether the control view should rotate with the main map view.\n * @property {HTMLElement|string} [target] Specify a target if you want the control\n * to be rendered outside of the map's viewport.\n * @property {string} [tipLabel='Overview map'] Text label to use for the button tip.\n * @property {View} [view] Custom view for the overview map (should use same projection as main map). If not provided,\n * a default view with the same projection as the main map will be used.\n */\n\n/**\n * Create a new control with a map acting as an overview map for another\n * defined map.\n *\n * @api\n */\nclass OverviewMap extends _Control_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  /**\n   * @param {Options} [options] OverviewMap options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super({\n      element: document.createElement('div'),\n      render: options.render,\n      target: options.target,\n    });\n\n    /**\n     * @private\n     */\n    this.boundHandleRotationChanged_ = this.handleRotationChanged_.bind(this);\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.collapsed_ =\n      options.collapsed !== undefined ? options.collapsed : true;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.collapsible_ =\n      options.collapsible !== undefined ? options.collapsible : true;\n\n    if (!this.collapsible_) {\n      this.collapsed_ = false;\n    }\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.rotateWithView_ =\n      options.rotateWithView !== undefined ? options.rotateWithView : false;\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent|undefined}\n     */\n    this.viewExtent_ = undefined;\n\n    const className =\n      options.className !== undefined ? options.className : 'ol-overviewmap';\n\n    const tipLabel =\n      options.tipLabel !== undefined ? options.tipLabel : 'Overview map';\n\n    const collapseLabel =\n      options.collapseLabel !== undefined ? options.collapseLabel : '\\u2039';\n\n    if (typeof collapseLabel === 'string') {\n      /**\n       * @private\n       * @type {HTMLElement}\n       */\n      this.collapseLabel_ = document.createElement('span');\n      this.collapseLabel_.textContent = collapseLabel;\n    } else {\n      this.collapseLabel_ = collapseLabel;\n    }\n\n    const label = options.label !== undefined ? options.label : '\\u203A';\n\n    if (typeof label === 'string') {\n      /**\n       * @private\n       * @type {HTMLElement}\n       */\n      this.label_ = document.createElement('span');\n      this.label_.textContent = label;\n    } else {\n      this.label_ = label;\n    }\n\n    const activeLabel =\n      this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_;\n    const button = document.createElement('button');\n    button.setAttribute('type', 'button');\n    button.title = tipLabel;\n    button.appendChild(activeLabel);\n\n    button.addEventListener(\n      _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].CLICK,\n      this.handleClick_.bind(this),\n      false,\n    );\n\n    /**\n     * @type {HTMLElement}\n     * @private\n     */\n    this.ovmapDiv_ = document.createElement('div');\n    this.ovmapDiv_.className = 'ol-overviewmap-map';\n\n    /**\n     * Explicitly given view to be used instead of a view derived from the main map.\n     * @type {View}\n     * @private\n     */\n    this.view_ = options.view;\n\n    const ovmap = new _Map_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]({\n      view: options.view,\n      controls: new _Collection_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](),\n      interactions: new _Collection_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](),\n    });\n\n    /**\n     * @type {Map}\n     * @private\n     */\n    this.ovmap_ = ovmap;\n\n    if (options.layers) {\n      options.layers.forEach(function (layer) {\n        ovmap.addLayer(layer);\n      });\n    }\n\n    const box = document.createElement('div');\n    box.className = 'ol-overviewmap-box';\n    box.style.boxSizing = 'border-box';\n\n    /**\n     * @type {import(\"../Overlay.js\").default}\n     * @private\n     */\n    this.boxOverlay_ = new _Overlay_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]({\n      position: [0, 0],\n      positioning: 'center-center',\n      element: box,\n    });\n    this.ovmap_.addOverlay(this.boxOverlay_);\n\n    const cssClasses =\n      className +\n      ' ' +\n      _css_js__WEBPACK_IMPORTED_MODULE_5__.CLASS_UNSELECTABLE +\n      ' ' +\n      _css_js__WEBPACK_IMPORTED_MODULE_5__.CLASS_CONTROL +\n      (this.collapsed_ && this.collapsible_ ? ' ' + _css_js__WEBPACK_IMPORTED_MODULE_5__.CLASS_COLLAPSED : '') +\n      (this.collapsible_ ? '' : ' ol-uncollapsible');\n    const element = this.element;\n    element.className = cssClasses;\n    element.appendChild(this.ovmapDiv_);\n    element.appendChild(button);\n\n    /* Interactive map */\n\n    const scope = this;\n\n    const overlay = this.boxOverlay_;\n    const overlayBox = this.boxOverlay_.getElement();\n\n    /* Functions definition */\n\n    const computeDesiredMousePosition = function (mousePosition) {\n      return {\n        clientX: mousePosition.clientX,\n        clientY: mousePosition.clientY,\n      };\n    };\n\n    const move = function (event) {\n      const position = /** @type {?} */ (computeDesiredMousePosition(event));\n      const coordinates = ovmap.getEventCoordinateInternal(\n        /** @type {MouseEvent} */ (position),\n      );\n\n      overlay.setPosition(coordinates);\n    };\n\n    const endMoving = function (event) {\n      const coordinates = ovmap.getEventCoordinateInternal(event);\n\n      scope.getMap().getView().setCenterInternal(coordinates);\n\n      window.removeEventListener('mousemove', move);\n      window.removeEventListener('mouseup', endMoving);\n    };\n\n    /* Binding */\n\n    overlayBox.addEventListener('mousedown', function () {\n      window.addEventListener('mousemove', move);\n      window.addEventListener('mouseup', endMoving);\n    });\n  }\n\n  /**\n   * Remove the control from its current map and attach it to the new map.\n   * Pass `null` to just remove the control from the current map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default|null} map Map.\n   * @api\n   */\n  setMap(map) {\n    const oldMap = this.getMap();\n    if (map === oldMap) {\n      return;\n    }\n    if (oldMap) {\n      const oldView = oldMap.getView();\n      if (oldView) {\n        this.unbindView_(oldView);\n      }\n      this.ovmap_.setTarget(null);\n    }\n    super.setMap(map);\n\n    if (map) {\n      this.ovmap_.setTarget(this.ovmapDiv_);\n      this.listenerKeys.push(\n        (0,_events_js__WEBPACK_IMPORTED_MODULE_6__.listen)(\n          map,\n          _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"].PROPERTYCHANGE,\n          this.handleMapPropertyChange_,\n          this,\n        ),\n      );\n\n      const view = map.getView();\n      if (view) {\n        this.bindView_(view);\n        if (view.isDef()) {\n          this.ovmap_.updateSize();\n          this.resetExtent_();\n        }\n      }\n\n      if (!this.ovmap_.isRendered()) {\n        this.updateBoxAfterOvmapIsRendered_();\n      }\n    }\n  }\n\n  /**\n   * Handle map property changes.  This only deals with changes to the map's view.\n   * @param {import(\"../Object.js\").ObjectEvent} event The propertychange event.\n   * @private\n   */\n  handleMapPropertyChange_(event) {\n    if (event.key === _MapProperty_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"].VIEW) {\n      const oldView = /** @type {import(\"../View.js\").default} */ (\n        event.oldValue\n      );\n      if (oldView) {\n        this.unbindView_(oldView);\n      }\n      const newView = this.getMap().getView();\n      this.bindView_(newView);\n    } else if (\n      !this.ovmap_.isRendered() &&\n      (event.key === _MapProperty_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"].TARGET || event.key === _MapProperty_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"].SIZE)\n    ) {\n      this.ovmap_.updateSize();\n    }\n  }\n\n  /**\n   * Register listeners for view property changes.\n   * @param {import(\"../View.js\").default} view The view.\n   * @private\n   */\n  bindView_(view) {\n    if (!this.view_) {\n      // Unless an explicit view definition was given, derive default from whatever main map uses.\n      const newView = new _View_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"]({\n        projection: view.getProjection(),\n      });\n      this.ovmap_.setView(newView);\n    }\n\n    view.addChangeListener(\n      _ViewProperty_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].ROTATION,\n      this.boundHandleRotationChanged_,\n    );\n    // Sync once with the new view\n    this.handleRotationChanged_();\n  }\n\n  /**\n   * Unregister listeners for view property changes.\n   * @param {import(\"../View.js\").default} view The view.\n   * @private\n   */\n  unbindView_(view) {\n    view.removeChangeListener(\n      _ViewProperty_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].ROTATION,\n      this.boundHandleRotationChanged_,\n    );\n  }\n\n  /**\n   * Handle rotation changes to the main map.\n   * @private\n   */\n  handleRotationChanged_() {\n    if (this.rotateWithView_) {\n      this.ovmap_.getView().setRotation(this.getMap().getView().getRotation());\n    }\n  }\n\n  /**\n   * Reset the overview map extent if the box size (width or\n   * height) is less than the size of the overview map size times minRatio\n   * or is greater than the size of the overview size times maxRatio.\n   *\n   * If the map extent was not reset, the box size can fits in the defined\n   * ratio sizes. This method then checks if is contained inside the overview\n   * map current extent. If not, recenter the overview map to the current\n   * main map center location.\n   * @private\n   */\n  validateExtent_() {\n    const map = this.getMap();\n    const ovmap = this.ovmap_;\n\n    if (!map.isRendered() || !ovmap.isRendered()) {\n      return;\n    }\n\n    const mapSize = /** @type {import(\"../size.js\").Size} */ (map.getSize());\n\n    const view = map.getView();\n    const extent = view.calculateExtentInternal(mapSize);\n\n    if (this.viewExtent_ && (0,_extent_js__WEBPACK_IMPORTED_MODULE_11__.equals)(extent, this.viewExtent_)) {\n      // repeats of the same extent may indicate constraint conflicts leading to an endless cycle\n      return;\n    }\n    this.viewExtent_ = extent;\n\n    const ovmapSize = /** @type {import(\"../size.js\").Size} */ (\n      ovmap.getSize()\n    );\n\n    const ovview = ovmap.getView();\n    const ovextent = ovview.calculateExtentInternal(ovmapSize);\n\n    const topLeftPixel = ovmap.getPixelFromCoordinateInternal(\n      (0,_extent_js__WEBPACK_IMPORTED_MODULE_11__.getTopLeft)(extent),\n    );\n    const bottomRightPixel = ovmap.getPixelFromCoordinateInternal(\n      (0,_extent_js__WEBPACK_IMPORTED_MODULE_11__.getBottomRight)(extent),\n    );\n\n    const boxWidth = Math.abs(topLeftPixel[0] - bottomRightPixel[0]);\n    const boxHeight = Math.abs(topLeftPixel[1] - bottomRightPixel[1]);\n\n    const ovmapWidth = ovmapSize[0];\n    const ovmapHeight = ovmapSize[1];\n\n    if (\n      boxWidth < ovmapWidth * MIN_RATIO ||\n      boxHeight < ovmapHeight * MIN_RATIO ||\n      boxWidth > ovmapWidth * MAX_RATIO ||\n      boxHeight > ovmapHeight * MAX_RATIO\n    ) {\n      this.resetExtent_();\n    } else if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_11__.containsExtent)(ovextent, extent)) {\n      this.recenter_();\n    }\n  }\n\n  /**\n   * Reset the overview map extent to half calculated min and max ratio times\n   * the extent of the main map.\n   * @private\n   */\n  resetExtent_() {\n    if (MAX_RATIO === 0 || MIN_RATIO === 0) {\n      return;\n    }\n\n    const map = this.getMap();\n    const ovmap = this.ovmap_;\n\n    const mapSize = /** @type {import(\"../size.js\").Size} */ (map.getSize());\n\n    const view = map.getView();\n    const extent = view.calculateExtentInternal(mapSize);\n\n    const ovview = ovmap.getView();\n\n    // get how many times the current map overview could hold different\n    // box sizes using the min and max ratio, pick the step in the middle used\n    // to calculate the extent from the main map to set it to the overview map,\n    const steps = Math.log(MAX_RATIO / MIN_RATIO) / Math.LN2;\n    const ratio = 1 / (Math.pow(2, steps / 2) * MIN_RATIO);\n    (0,_extent_js__WEBPACK_IMPORTED_MODULE_11__.scaleFromCenter)(extent, ratio);\n    ovview.fitInternal((0,_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_12__.fromExtent)(extent));\n  }\n\n  /**\n   * Set the center of the overview map to the map center without changing its\n   * resolution.\n   * @private\n   */\n  recenter_() {\n    const map = this.getMap();\n    const ovmap = this.ovmap_;\n\n    const view = map.getView();\n\n    const ovview = ovmap.getView();\n\n    ovview.setCenterInternal(view.getCenterInternal());\n  }\n\n  /**\n   * Update the box using the main map extent\n   * @private\n   */\n  updateBox_() {\n    const map = this.getMap();\n    const ovmap = this.ovmap_;\n\n    if (!map.isRendered() || !ovmap.isRendered()) {\n      return;\n    }\n\n    const mapSize = /** @type {import(\"../size.js\").Size} */ (map.getSize());\n\n    const view = map.getView();\n\n    const ovview = ovmap.getView();\n\n    const rotation = this.rotateWithView_ ? 0 : -view.getRotation();\n\n    const overlay = this.boxOverlay_;\n    const box = this.boxOverlay_.getElement();\n    const center = view.getCenterInternal();\n    const resolution = view.getResolution();\n    const ovresolution = ovview.getResolution();\n    const width = (mapSize[0] * resolution) / ovresolution;\n    const height = (mapSize[1] * resolution) / ovresolution;\n\n    // set position using center coordinates\n    overlay.setPosition(center);\n\n    // set box size calculated from map extent size and overview map resolution\n    if (box) {\n      box.style.width = width + 'px';\n      box.style.height = height + 'px';\n      const transform = 'rotate(' + rotation + 'rad)';\n      box.style.transform = transform;\n    }\n  }\n\n  /**\n   * @private\n   */\n  updateBoxAfterOvmapIsRendered_() {\n    if (this.ovmapPostrenderKey_) {\n      return;\n    }\n    this.ovmapPostrenderKey_ = (0,_events_js__WEBPACK_IMPORTED_MODULE_6__.listenOnce)(\n      this.ovmap_,\n      _MapEventType_js__WEBPACK_IMPORTED_MODULE_13__[\"default\"].POSTRENDER,\n      function (event) {\n        delete this.ovmapPostrenderKey_;\n        this.updateBox_();\n      },\n      this,\n    );\n  }\n\n  /**\n   * @param {MouseEvent} event The event to handle\n   * @private\n   */\n  handleClick_(event) {\n    event.preventDefault();\n    this.handleToggle_();\n  }\n\n  /**\n   * @private\n   */\n  handleToggle_() {\n    this.element.classList.toggle(_css_js__WEBPACK_IMPORTED_MODULE_5__.CLASS_COLLAPSED);\n    if (this.collapsed_) {\n      (0,_dom_js__WEBPACK_IMPORTED_MODULE_14__.replaceNode)(this.collapseLabel_, this.label_);\n    } else {\n      (0,_dom_js__WEBPACK_IMPORTED_MODULE_14__.replaceNode)(this.label_, this.collapseLabel_);\n    }\n    this.collapsed_ = !this.collapsed_;\n\n    // manage overview map if it had not been rendered before and control\n    // is expanded\n    const ovmap = this.ovmap_;\n    if (!this.collapsed_) {\n      if (ovmap.isRendered()) {\n        this.viewExtent_ = undefined;\n        ovmap.render();\n        return;\n      }\n      ovmap.updateSize();\n      this.resetExtent_();\n      this.updateBoxAfterOvmapIsRendered_();\n    }\n  }\n\n  /**\n   * Return `true` if the overview map is collapsible, `false` otherwise.\n   * @return {boolean} True if the widget is collapsible.\n   * @api\n   */\n  getCollapsible() {\n    return this.collapsible_;\n  }\n\n  /**\n   * Set whether the overview map should be collapsible.\n   * @param {boolean} collapsible True if the widget is collapsible.\n   * @api\n   */\n  setCollapsible(collapsible) {\n    if (this.collapsible_ === collapsible) {\n      return;\n    }\n    this.collapsible_ = collapsible;\n    this.element.classList.toggle('ol-uncollapsible');\n    if (!collapsible && this.collapsed_) {\n      this.handleToggle_();\n    }\n  }\n\n  /**\n   * Collapse or expand the overview map according to the passed parameter. Will\n   * not do anything if the overview map isn't collapsible or if the current\n   * collapsed state is already the one requested.\n   * @param {boolean} collapsed True if the widget is collapsed.\n   * @api\n   */\n  setCollapsed(collapsed) {\n    if (!this.collapsible_ || this.collapsed_ === collapsed) {\n      return;\n    }\n    this.handleToggle_();\n  }\n\n  /**\n   * Determine if the overview map is collapsed.\n   * @return {boolean} The overview map is collapsed.\n   * @api\n   */\n  getCollapsed() {\n    return this.collapsed_;\n  }\n\n  /**\n   * Return `true` if the overview map view can rotate, `false` otherwise.\n   * @return {boolean} True if the control view can rotate.\n   * @api\n   */\n  getRotateWithView() {\n    return this.rotateWithView_;\n  }\n\n  /**\n   * Set whether the overview map view should rotate with the main map view.\n   * @param {boolean} rotateWithView True if the control view should rotate.\n   * @api\n   */\n  setRotateWithView(rotateWithView) {\n    if (this.rotateWithView_ === rotateWithView) {\n      return;\n    }\n    this.rotateWithView_ = rotateWithView;\n    if (this.getMap().getView().getRotation() !== 0) {\n      if (this.rotateWithView_) {\n        this.handleRotationChanged_();\n      } else {\n        this.ovmap_.getView().setRotation(0);\n      }\n      this.viewExtent_ = undefined;\n      this.validateExtent_();\n      this.updateBox_();\n    }\n  }\n\n  /**\n   * Return the overview map.\n   * @return {import(\"../Map.js\").default} Overview map.\n   * @api\n   */\n  getOverviewMap() {\n    return this.ovmap_;\n  }\n\n  /**\n   * Update the overview map element.\n   * @param {import(\"../MapEvent.js\").default} mapEvent Map event.\n   * @override\n   */\n  render(mapEvent) {\n    this.validateExtent_();\n    this.updateBox_();\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (OverviewMap);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vbC9jb250cm9sL092ZXJ2aWV3TWFwLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDMEM7QUFDUDtBQUNZO0FBQ25CO0FBQ2tCO0FBQ0Y7QUFDUTtBQUNoQjtBQUNOO0FBQ2dCO0FBQytCO0FBT3ZEO0FBQzBCO0FBQ21CO0FBQzdCOztBQUV0QztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsb0JBQW9CO0FBQ2xDO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsb0JBQW9CO0FBQ2xDO0FBQ0EsY0FBYyxrSEFBa0g7QUFDaEk7QUFDQSxjQUFjLGlEQUFpRDtBQUMvRDtBQUNBLGNBQWMsU0FBUztBQUN2QixjQUFjLG9CQUFvQjtBQUNsQztBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLE1BQU07QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbURBQU87QUFDakM7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFD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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyw2QkFBNkI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxrQ0FBa0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0RBQWUsV0FBVyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9vbC9jb250cm9sL092ZXJ2aWV3TWFwLmpzPzIwMTIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIG9sL2NvbnRyb2wvT3ZlcnZpZXdNYXBcbiAqL1xuaW1wb3J0IENvbGxlY3Rpb24gZnJvbSAnLi4vQ29sbGVjdGlvbi5qcyc7XG5pbXBvcnQgQ29udHJvbCBmcm9tICcuL0NvbnRyb2wuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBNYXAgZnJvbSAnLi4vTWFwLmpzJztcbmltcG9ydCBNYXBFdmVudFR5cGUgZnJvbSAnLi4vTWFwRXZlbnRUeXBlLmpzJztcbmltcG9ydCBNYXBQcm9wZXJ0eSBmcm9tICcuLi9NYXBQcm9wZXJ0eS5qcyc7XG5pbXBvcnQgT2JqZWN0RXZlbnRUeXBlIGZyb20gJy4uL09iamVjdEV2ZW50VHlwZS5qcyc7XG5pbXBvcnQgT3ZlcmxheSBmcm9tICcuLi9PdmVybGF5LmpzJztcbmltcG9ydCBWaWV3IGZyb20gJy4uL1ZpZXcuanMnO1xuaW1wb3J0IFZpZXdQcm9wZXJ0eSBmcm9tICcuLi9WaWV3UHJvcGVydHkuanMnO1xuaW1wb3J0IHtDTEFTU19DT0xMQVBTRUQsIENMQVNTX0NPTlRST0wsIENMQVNTX1VOU0VMRUNUQUJMRX0gZnJvbSAnLi4vY3NzLmpzJztcbmltcG9ydCB7XG4gIGNvbnRhaW5zRXh0ZW50LFxuICBlcXVhbHMgYXMgZXF1YWxzRXh0ZW50LFxuICBnZXRCb3R0b21SaWdodCxcbiAgZ2V0VG9wTGVmdCxcbiAgc2NhbGVGcm9tQ2VudGVyLFxufSBmcm9tICcuLi9leHRlbnQuanMnO1xuaW1wb3J0IHtsaXN0ZW4sIGxpc3Rlbk9uY2V9IGZyb20gJy4uL2V2ZW50cy5qcyc7XG5pbXBvcnQge2Zyb21FeHRlbnQgYXMgcG9seWdvbkZyb21FeHRlbnR9IGZyb20gJy4uL2dlb20vUG9seWdvbi5qcyc7XG5pbXBvcnQge3JlcGxhY2VOb2RlfSBmcm9tICcuLi9kb20uanMnO1xuXG4vKipcbiAqIE1heGltdW0gd2lkdGggYW5kL29yIGhlaWdodCBleHRlbnQgcmF0aW8gdGhhdCBkZXRlcm1pbmVzIHdoZW4gdGhlIG92ZXJ2aWV3XG4gKiBtYXAgc2hvdWxkIGJlIHpvb21lZCBvdXQuXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5jb25zdCBNQVhfUkFUSU8gPSAwLjc1O1xuXG4vKipcbiAqIE1pbmltdW0gd2lkdGggYW5kL29yIGhlaWdodCBleHRlbnQgcmF0aW8gdGhhdCBkZXRlcm1pbmVzIHdoZW4gdGhlIG92ZXJ2aWV3XG4gKiBtYXAgc2hvdWxkIGJlIHpvb21lZCBpbi5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmNvbnN0IE1JTl9SQVRJTyA9IDAuMTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzTmFtZT0nb2wtb3ZlcnZpZXdtYXAnXSBDU1MgY2xhc3MgbmFtZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2NvbGxhcHNlZD10cnVlXSBXaGV0aGVyIHRoZSBjb250cm9sIHNob3VsZCBzdGFydCBjb2xsYXBzZWQgb3Igbm90IChleHBhbmRlZCkuXG4gKiBAcHJvcGVydHkge3N0cmluZ3xIVE1MRWxlbWVudH0gW2NvbGxhcHNlTGFiZWw9J+KAuSddIFRleHQgbGFiZWwgdG8gdXNlIGZvciB0aGVcbiAqIGV4cGFuZGVkIG92ZXJ2aWV3bWFwIGJ1dHRvbi4gSW5zdGVhZCBvZiB0ZXh0LCBhbHNvIGFuIGVsZW1lbnQgKGUuZy4gYSBgc3BhbmAgZWxlbWVudCkgY2FuIGJlIHVzZWQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjb2xsYXBzaWJsZT10cnVlXSBXaGV0aGVyIHRoZSBjb250cm9sIGNhbiBiZSBjb2xsYXBzZWQgb3Igbm90LlxuICogQHByb3BlcnR5IHtzdHJpbmd8SFRNTEVsZW1lbnR9IFtsYWJlbD0n4oC6J10gVGV4dCBsYWJlbCB0byB1c2UgZm9yIHRoZSBjb2xsYXBzZWRcbiAqIG92ZXJ2aWV3bWFwIGJ1dHRvbi4gSW5zdGVhZCBvZiB0ZXh0LCBhbHNvIGFuIGVsZW1lbnQgKGUuZy4gYSBgc3BhbmAgZWxlbWVudCkgY2FuIGJlIHVzZWQuXG4gKiBAcHJvcGVydHkge0FycmF5PGltcG9ydChcIi4uL2xheWVyL0Jhc2UuanNcIikuZGVmYXVsdD58aW1wb3J0KFwiLi4vQ29sbGVjdGlvbi5qc1wiKS5kZWZhdWx0PGltcG9ydChcIi4uL2xheWVyL0Jhc2UuanNcIikuZGVmYXVsdD59IFtsYXllcnNdXG4gKiBMYXllcnMgZm9yIHRoZSBvdmVydmlldyBtYXAuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKGltcG9ydChcIi4uL01hcEV2ZW50LmpzXCIpLmRlZmF1bHQpOnZvaWR9IFtyZW5kZXJdIEZ1bmN0aW9uIGNhbGxlZCB3aGVuIHRoZSBjb250cm9sXG4gKiBzaG91bGQgYmUgcmUtcmVuZGVyZWQuIFRoaXMgaXMgY2FsbGVkIGluIGEgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgY2FsbGJhY2suXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyb3RhdGVXaXRoVmlldz1mYWxzZV0gV2hldGhlciB0aGUgY29udHJvbCB2aWV3IHNob3VsZCByb3RhdGUgd2l0aCB0aGUgbWFpbiBtYXAgdmlldy5cbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR8c3RyaW5nfSBbdGFyZ2V0XSBTcGVjaWZ5IGEgdGFyZ2V0IGlmIHlvdSB3YW50IHRoZSBjb250cm9sXG4gKiB0byBiZSByZW5kZXJlZCBvdXRzaWRlIG9mIHRoZSBtYXAncyB2aWV3cG9ydC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdGlwTGFiZWw9J092ZXJ2aWV3IG1hcCddIFRleHQgbGFiZWwgdG8gdXNlIGZvciB0aGUgYnV0dG9uIHRpcC5cbiAqIEBwcm9wZXJ0eSB7Vmlld30gW3ZpZXddIEN1c3RvbSB2aWV3IGZvciB0aGUgb3ZlcnZpZXcgbWFwIChzaG91bGQgdXNlIHNhbWUgcHJvamVjdGlvbiBhcyBtYWluIG1hcCkuIElmIG5vdCBwcm92aWRlZCxcbiAqIGEgZGVmYXVsdCB2aWV3IHdpdGggdGhlIHNhbWUgcHJvamVjdGlvbiBhcyB0aGUgbWFpbiBtYXAgd2lsbCBiZSB1c2VkLlxuICovXG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGNvbnRyb2wgd2l0aCBhIG1hcCBhY3RpbmcgYXMgYW4gb3ZlcnZpZXcgbWFwIGZvciBhbm90aGVyXG4gKiBkZWZpbmVkIG1hcC5cbiAqXG4gKiBAYXBpXG4gKi9cbmNsYXNzIE92ZXJ2aWV3TWFwIGV4dGVuZHMgQ29udHJvbCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSBPdmVydmlld01hcCBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zID8gb3B0aW9ucyA6IHt9O1xuXG4gICAgc3VwZXIoe1xuICAgICAgZWxlbWVudDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgICByZW5kZXI6IG9wdGlvbnMucmVuZGVyLFxuICAgICAgdGFyZ2V0OiBvcHRpb25zLnRhcmdldCxcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5ib3VuZEhhbmRsZVJvdGF0aW9uQ2hhbmdlZF8gPSB0aGlzLmhhbmRsZVJvdGF0aW9uQ2hhbmdlZF8uYmluZCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5jb2xsYXBzZWRfID1cbiAgICAgIG9wdGlvbnMuY29sbGFwc2VkICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNvbGxhcHNlZCA6IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuY29sbGFwc2libGVfID1cbiAgICAgIG9wdGlvbnMuY29sbGFwc2libGUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY29sbGFwc2libGUgOiB0cnVlO1xuXG4gICAgaWYgKCF0aGlzLmNvbGxhcHNpYmxlXykge1xuICAgICAgdGhpcy5jb2xsYXBzZWRfID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJvdGF0ZVdpdGhWaWV3XyA9XG4gICAgICBvcHRpb25zLnJvdGF0ZVdpdGhWaWV3ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnJvdGF0ZVdpdGhWaWV3IDogZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnZpZXdFeHRlbnRfID0gdW5kZWZpbmVkO1xuXG4gICAgY29uc3QgY2xhc3NOYW1lID1cbiAgICAgIG9wdGlvbnMuY2xhc3NOYW1lICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNsYXNzTmFtZSA6ICdvbC1vdmVydmlld21hcCc7XG5cbiAgICBjb25zdCB0aXBMYWJlbCA9XG4gICAgICBvcHRpb25zLnRpcExhYmVsICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnRpcExhYmVsIDogJ092ZXJ2aWV3IG1hcCc7XG5cbiAgICBjb25zdCBjb2xsYXBzZUxhYmVsID1cbiAgICAgIG9wdGlvbnMuY29sbGFwc2VMYWJlbCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jb2xsYXBzZUxhYmVsIDogJ1xcdTIwMzknO1xuXG4gICAgaWYgKHR5cGVvZiBjb2xsYXBzZUxhYmVsID09PSAnc3RyaW5nJykge1xuICAgICAgLyoqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAgICovXG4gICAgICB0aGlzLmNvbGxhcHNlTGFiZWxfID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgdGhpcy5jb2xsYXBzZUxhYmVsXy50ZXh0Q29udGVudCA9IGNvbGxhcHNlTGFiZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29sbGFwc2VMYWJlbF8gPSBjb2xsYXBzZUxhYmVsO1xuICAgIH1cblxuICAgIGNvbnN0IGxhYmVsID0gb3B0aW9ucy5sYWJlbCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5sYWJlbCA6ICdcXHUyMDNBJztcblxuICAgIGlmICh0eXBlb2YgbGFiZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvKipcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICAgKi9cbiAgICAgIHRoaXMubGFiZWxfID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgdGhpcy5sYWJlbF8udGV4dENvbnRlbnQgPSBsYWJlbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sYWJlbF8gPSBsYWJlbDtcbiAgICB9XG5cbiAgICBjb25zdCBhY3RpdmVMYWJlbCA9XG4gICAgICB0aGlzLmNvbGxhcHNpYmxlXyAmJiAhdGhpcy5jb2xsYXBzZWRfID8gdGhpcy5jb2xsYXBzZUxhYmVsXyA6IHRoaXMubGFiZWxfO1xuICAgIGNvbnN0IGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnYnV0dG9uJyk7XG4gICAgYnV0dG9uLnRpdGxlID0gdGlwTGFiZWw7XG4gICAgYnV0dG9uLmFwcGVuZENoaWxkKGFjdGl2ZUxhYmVsKTtcblxuICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgRXZlbnRUeXBlLkNMSUNLLFxuICAgICAgdGhpcy5oYW5kbGVDbGlja18uYmluZCh0aGlzKSxcbiAgICAgIGZhbHNlLFxuICAgICk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLm92bWFwRGl2XyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMub3ZtYXBEaXZfLmNsYXNzTmFtZSA9ICdvbC1vdmVydmlld21hcC1tYXAnO1xuXG4gICAgLyoqXG4gICAgICogRXhwbGljaXRseSBnaXZlbiB2aWV3IHRvIGJlIHVzZWQgaW5zdGVhZCBvZiBhIHZpZXcgZGVyaXZlZCBmcm9tIHRoZSBtYWluIG1hcC5cbiAgICAgKiBAdHlwZSB7Vmlld31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudmlld18gPSBvcHRpb25zLnZpZXc7XG5cbiAgICBjb25zdCBvdm1hcCA9IG5ldyBNYXAoe1xuICAgICAgdmlldzogb3B0aW9ucy52aWV3LFxuICAgICAgY29udHJvbHM6IG5ldyBDb2xsZWN0aW9uKCksXG4gICAgICBpbnRlcmFjdGlvbnM6IG5ldyBDb2xsZWN0aW9uKCksXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TWFwfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5vdm1hcF8gPSBvdm1hcDtcblxuICAgIGlmIChvcHRpb25zLmxheWVycykge1xuICAgICAgb3B0aW9ucy5sYXllcnMuZm9yRWFjaChmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgb3ZtYXAuYWRkTGF5ZXIobGF5ZXIpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgYm94LmNsYXNzTmFtZSA9ICdvbC1vdmVydmlld21hcC1ib3gnO1xuICAgIGJveC5zdHlsZS5ib3hTaXppbmcgPSAnYm9yZGVyLWJveCc7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vT3ZlcmxheS5qc1wiKS5kZWZhdWx0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5ib3hPdmVybGF5XyA9IG5ldyBPdmVybGF5KHtcbiAgICAgIHBvc2l0aW9uOiBbMCwgMF0sXG4gICAgICBwb3NpdGlvbmluZzogJ2NlbnRlci1jZW50ZXInLFxuICAgICAgZWxlbWVudDogYm94LFxuICAgIH0pO1xuICAgIHRoaXMub3ZtYXBfLmFkZE92ZXJsYXkodGhpcy5ib3hPdmVybGF5Xyk7XG5cbiAgICBjb25zdCBjc3NDbGFzc2VzID1cbiAgICAgIGNsYXNzTmFtZSArXG4gICAgICAnICcgK1xuICAgICAgQ0xBU1NfVU5TRUxFQ1RBQkxFICtcbiAgICAgICcgJyArXG4gICAgICBDTEFTU19DT05UUk9MICtcbiAgICAgICh0aGlzLmNvbGxhcHNlZF8gJiYgdGhpcy5jb2xsYXBzaWJsZV8gPyAnICcgKyBDTEFTU19DT0xMQVBTRUQgOiAnJykgK1xuICAgICAgKHRoaXMuY29sbGFwc2libGVfID8gJycgOiAnIG9sLXVuY29sbGFwc2libGUnKTtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gY3NzQ2xhc3NlcztcbiAgICBlbGVtZW50LmFwcGVuZENoaWxkKHRoaXMub3ZtYXBEaXZfKTtcbiAgICBlbGVtZW50LmFwcGVuZENoaWxkKGJ1dHRvbik7XG5cbiAgICAvKiBJbnRlcmFjdGl2ZSBtYXAgKi9cblxuICAgIGNvbnN0IHNjb3BlID0gdGhpcztcblxuICAgIGNvbnN0IG92ZXJsYXkgPSB0aGlzLmJveE92ZXJsYXlfO1xuICAgIGNvbnN0IG92ZXJsYXlCb3ggPSB0aGlzLmJveE92ZXJsYXlfLmdldEVsZW1lbnQoKTtcblxuICAgIC8qIEZ1bmN0aW9ucyBkZWZpbml0aW9uICovXG5cbiAgICBjb25zdCBjb21wdXRlRGVzaXJlZE1vdXNlUG9zaXRpb24gPSBmdW5jdGlvbiAobW91c2VQb3NpdGlvbikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2xpZW50WDogbW91c2VQb3NpdGlvbi5jbGllbnRYLFxuICAgICAgICBjbGllbnRZOiBtb3VzZVBvc2l0aW9uLmNsaWVudFksXG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBtb3ZlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IC8qKiBAdHlwZSB7P30gKi8gKGNvbXB1dGVEZXNpcmVkTW91c2VQb3NpdGlvbihldmVudCkpO1xuICAgICAgY29uc3QgY29vcmRpbmF0ZXMgPSBvdm1hcC5nZXRFdmVudENvb3JkaW5hdGVJbnRlcm5hbChcbiAgICAgICAgLyoqIEB0eXBlIHtNb3VzZUV2ZW50fSAqLyAocG9zaXRpb24pLFxuICAgICAgKTtcblxuICAgICAgb3ZlcmxheS5zZXRQb3NpdGlvbihjb29yZGluYXRlcyk7XG4gICAgfTtcblxuICAgIGNvbnN0IGVuZE1vdmluZyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgY29uc3QgY29vcmRpbmF0ZXMgPSBvdm1hcC5nZXRFdmVudENvb3JkaW5hdGVJbnRlcm5hbChldmVudCk7XG5cbiAgICAgIHNjb3BlLmdldE1hcCgpLmdldFZpZXcoKS5zZXRDZW50ZXJJbnRlcm5hbChjb29yZGluYXRlcyk7XG5cbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBtb3ZlKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgZW5kTW92aW5nKTtcbiAgICB9O1xuXG4gICAgLyogQmluZGluZyAqL1xuXG4gICAgb3ZlcmxheUJveC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBmdW5jdGlvbiAoKSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbW92ZSk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGVuZE1vdmluZyk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBjb250cm9sIGZyb20gaXRzIGN1cnJlbnQgbWFwIGFuZCBhdHRhY2ggaXQgdG8gdGhlIG5ldyBtYXAuXG4gICAqIFBhc3MgYG51bGxgIHRvIGp1c3QgcmVtb3ZlIHRoZSBjb250cm9sIGZyb20gdGhlIGN1cnJlbnQgbWFwLlxuICAgKiBTdWJjbGFzc2VzIG1heSBzZXQgdXAgZXZlbnQgaGFuZGxlcnMgdG8gZ2V0IG5vdGlmaWVkIGFib3V0IGNoYW5nZXMgdG9cbiAgICogdGhlIG1hcCBoZXJlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcC5qc1wiKS5kZWZhdWx0fG51bGx9IG1hcCBNYXAuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldE1hcChtYXApIHtcbiAgICBjb25zdCBvbGRNYXAgPSB0aGlzLmdldE1hcCgpO1xuICAgIGlmIChtYXAgPT09IG9sZE1hcCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAob2xkTWFwKSB7XG4gICAgICBjb25zdCBvbGRWaWV3ID0gb2xkTWFwLmdldFZpZXcoKTtcbiAgICAgIGlmIChvbGRWaWV3KSB7XG4gICAgICAgIHRoaXMudW5iaW5kVmlld18ob2xkVmlldyk7XG4gICAgICB9XG4gICAgICB0aGlzLm92bWFwXy5zZXRUYXJnZXQobnVsbCk7XG4gICAgfVxuICAgIHN1cGVyLnNldE1hcChtYXApO1xuXG4gICAgaWYgKG1hcCkge1xuICAgICAgdGhpcy5vdm1hcF8uc2V0VGFyZ2V0KHRoaXMub3ZtYXBEaXZfKTtcbiAgICAgIHRoaXMubGlzdGVuZXJLZXlzLnB1c2goXG4gICAgICAgIGxpc3RlbihcbiAgICAgICAgICBtYXAsXG4gICAgICAgICAgT2JqZWN0RXZlbnRUeXBlLlBST1BFUlRZQ0hBTkdFLFxuICAgICAgICAgIHRoaXMuaGFuZGxlTWFwUHJvcGVydHlDaGFuZ2VfLFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICksXG4gICAgICApO1xuXG4gICAgICBjb25zdCB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgIHRoaXMuYmluZFZpZXdfKHZpZXcpO1xuICAgICAgICBpZiAodmlldy5pc0RlZigpKSB7XG4gICAgICAgICAgdGhpcy5vdm1hcF8udXBkYXRlU2l6ZSgpO1xuICAgICAgICAgIHRoaXMucmVzZXRFeHRlbnRfKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLm92bWFwXy5pc1JlbmRlcmVkKCkpIHtcbiAgICAgICAgdGhpcy51cGRhdGVCb3hBZnRlck92bWFwSXNSZW5kZXJlZF8oKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIG1hcCBwcm9wZXJ0eSBjaGFuZ2VzLiAgVGhpcyBvbmx5IGRlYWxzIHdpdGggY2hhbmdlcyB0byB0aGUgbWFwJ3Mgdmlldy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9PYmplY3QuanNcIikuT2JqZWN0RXZlbnR9IGV2ZW50IFRoZSBwcm9wZXJ0eWNoYW5nZSBldmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZU1hcFByb3BlcnR5Q2hhbmdlXyhldmVudCkge1xuICAgIGlmIChldmVudC5rZXkgPT09IE1hcFByb3BlcnR5LlZJRVcpIHtcbiAgICAgIGNvbnN0IG9sZFZpZXcgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uL1ZpZXcuanNcIikuZGVmYXVsdH0gKi8gKFxuICAgICAgICBldmVudC5vbGRWYWx1ZVxuICAgICAgKTtcbiAgICAgIGlmIChvbGRWaWV3KSB7XG4gICAgICAgIHRoaXMudW5iaW5kVmlld18ob2xkVmlldyk7XG4gICAgICB9XG4gICAgICBjb25zdCBuZXdWaWV3ID0gdGhpcy5nZXRNYXAoKS5nZXRWaWV3KCk7XG4gICAgICB0aGlzLmJpbmRWaWV3XyhuZXdWaWV3KTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgIXRoaXMub3ZtYXBfLmlzUmVuZGVyZWQoKSAmJlxuICAgICAgKGV2ZW50LmtleSA9PT0gTWFwUHJvcGVydHkuVEFSR0VUIHx8IGV2ZW50LmtleSA9PT0gTWFwUHJvcGVydHkuU0laRSlcbiAgICApIHtcbiAgICAgIHRoaXMub3ZtYXBfLnVwZGF0ZVNpemUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgbGlzdGVuZXJzIGZvciB2aWV3IHByb3BlcnR5IGNoYW5nZXMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vVmlldy5qc1wiKS5kZWZhdWx0fSB2aWV3IFRoZSB2aWV3LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYmluZFZpZXdfKHZpZXcpIHtcbiAgICBpZiAoIXRoaXMudmlld18pIHtcbiAgICAgIC8vIFVubGVzcyBhbiBleHBsaWNpdCB2aWV3IGRlZmluaXRpb24gd2FzIGdpdmVuLCBkZXJpdmUgZGVmYXVsdCBmcm9tIHdoYXRldmVyIG1haW4gbWFwIHVzZXMuXG4gICAgICBjb25zdCBuZXdWaWV3ID0gbmV3IFZpZXcoe1xuICAgICAgICBwcm9qZWN0aW9uOiB2aWV3LmdldFByb2plY3Rpb24oKSxcbiAgICAgIH0pO1xuICAgICAgdGhpcy5vdm1hcF8uc2V0VmlldyhuZXdWaWV3KTtcbiAgICB9XG5cbiAgICB2aWV3LmFkZENoYW5nZUxpc3RlbmVyKFxuICAgICAgVmlld1Byb3BlcnR5LlJPVEFUSU9OLFxuICAgICAgdGhpcy5ib3VuZEhhbmRsZVJvdGF0aW9uQ2hhbmdlZF8sXG4gICAgKTtcbiAgICAvLyBTeW5jIG9uY2Ugd2l0aCB0aGUgbmV3IHZpZXdcbiAgICB0aGlzLmhhbmRsZVJvdGF0aW9uQ2hhbmdlZF8oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnJlZ2lzdGVyIGxpc3RlbmVycyBmb3IgdmlldyBwcm9wZXJ0eSBjaGFuZ2VzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL1ZpZXcuanNcIikuZGVmYXVsdH0gdmlldyBUaGUgdmlldy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHVuYmluZFZpZXdfKHZpZXcpIHtcbiAgICB2aWV3LnJlbW92ZUNoYW5nZUxpc3RlbmVyKFxuICAgICAgVmlld1Byb3BlcnR5LlJPVEFUSU9OLFxuICAgICAgdGhpcy5ib3VuZEhhbmRsZVJvdGF0aW9uQ2hhbmdlZF8sXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgcm90YXRpb24gY2hhbmdlcyB0byB0aGUgbWFpbiBtYXAuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVSb3RhdGlvbkNoYW5nZWRfKCkge1xuICAgIGlmICh0aGlzLnJvdGF0ZVdpdGhWaWV3Xykge1xuICAgICAgdGhpcy5vdm1hcF8uZ2V0VmlldygpLnNldFJvdGF0aW9uKHRoaXMuZ2V0TWFwKCkuZ2V0VmlldygpLmdldFJvdGF0aW9uKCkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCB0aGUgb3ZlcnZpZXcgbWFwIGV4dGVudCBpZiB0aGUgYm94IHNpemUgKHdpZHRoIG9yXG4gICAqIGhlaWdodCkgaXMgbGVzcyB0aGFuIHRoZSBzaXplIG9mIHRoZSBvdmVydmlldyBtYXAgc2l6ZSB0aW1lcyBtaW5SYXRpb1xuICAgKiBvciBpcyBncmVhdGVyIHRoYW4gdGhlIHNpemUgb2YgdGhlIG92ZXJ2aWV3IHNpemUgdGltZXMgbWF4UmF0aW8uXG4gICAqXG4gICAqIElmIHRoZSBtYXAgZXh0ZW50IHdhcyBub3QgcmVzZXQsIHRoZSBib3ggc2l6ZSBjYW4gZml0cyBpbiB0aGUgZGVmaW5lZFxuICAgKiByYXRpbyBzaXplcy4gVGhpcyBtZXRob2QgdGhlbiBjaGVja3MgaWYgaXMgY29udGFpbmVkIGluc2lkZSB0aGUgb3ZlcnZpZXdcbiAgICogbWFwIGN1cnJlbnQgZXh0ZW50LiBJZiBub3QsIHJlY2VudGVyIHRoZSBvdmVydmlldyBtYXAgdG8gdGhlIGN1cnJlbnRcbiAgICogbWFpbiBtYXAgY2VudGVyIGxvY2F0aW9uLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdmFsaWRhdGVFeHRlbnRfKCkge1xuICAgIGNvbnN0IG1hcCA9IHRoaXMuZ2V0TWFwKCk7XG4gICAgY29uc3Qgb3ZtYXAgPSB0aGlzLm92bWFwXztcblxuICAgIGlmICghbWFwLmlzUmVuZGVyZWQoKSB8fCAhb3ZtYXAuaXNSZW5kZXJlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbWFwU2l6ZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSAqLyAobWFwLmdldFNpemUoKSk7XG5cbiAgICBjb25zdCB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICBjb25zdCBleHRlbnQgPSB2aWV3LmNhbGN1bGF0ZUV4dGVudEludGVybmFsKG1hcFNpemUpO1xuXG4gICAgaWYgKHRoaXMudmlld0V4dGVudF8gJiYgZXF1YWxzRXh0ZW50KGV4dGVudCwgdGhpcy52aWV3RXh0ZW50XykpIHtcbiAgICAgIC8vIHJlcGVhdHMgb2YgdGhlIHNhbWUgZXh0ZW50IG1heSBpbmRpY2F0ZSBjb25zdHJhaW50IGNvbmZsaWN0cyBsZWFkaW5nIHRvIGFuIGVuZGxlc3MgY3ljbGVcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy52aWV3RXh0ZW50XyA9IGV4dGVudDtcblxuICAgIGNvbnN0IG92bWFwU2l6ZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSAqLyAoXG4gICAgICBvdm1hcC5nZXRTaXplKClcbiAgICApO1xuXG4gICAgY29uc3Qgb3Z2aWV3ID0gb3ZtYXAuZ2V0VmlldygpO1xuICAgIGNvbnN0IG92ZXh0ZW50ID0gb3Z2aWV3LmNhbGN1bGF0ZUV4dGVudEludGVybmFsKG92bWFwU2l6ZSk7XG5cbiAgICBjb25zdCB0b3BMZWZ0UGl4ZWwgPSBvdm1hcC5nZXRQaXhlbEZyb21Db29yZGluYXRlSW50ZXJuYWwoXG4gICAgICBnZXRUb3BMZWZ0KGV4dGVudCksXG4gICAgKTtcbiAgICBjb25zdCBib3R0b21SaWdodFBpeGVsID0gb3ZtYXAuZ2V0UGl4ZWxGcm9tQ29vcmRpbmF0ZUludGVybmFsKFxuICAgICAgZ2V0Qm90dG9tUmlnaHQoZXh0ZW50KSxcbiAgICApO1xuXG4gICAgY29uc3QgYm94V2lkdGggPSBNYXRoLmFicyh0b3BMZWZ0UGl4ZWxbMF0gLSBib3R0b21SaWdodFBpeGVsWzBdKTtcbiAgICBjb25zdCBib3hIZWlnaHQgPSBNYXRoLmFicyh0b3BMZWZ0UGl4ZWxbMV0gLSBib3R0b21SaWdodFBpeGVsWzFdKTtcblxuICAgIGNvbnN0IG92bWFwV2lkdGggPSBvdm1hcFNpemVbMF07XG4gICAgY29uc3Qgb3ZtYXBIZWlnaHQgPSBvdm1hcFNpemVbMV07XG5cbiAgICBpZiAoXG4gICAgICBib3hXaWR0aCA8IG92bWFwV2lkdGggKiBNSU5fUkFUSU8gfHxcbiAgICAgIGJveEhlaWdodCA8IG92bWFwSGVpZ2h0ICogTUlOX1JBVElPIHx8XG4gICAgICBib3hXaWR0aCA+IG92bWFwV2lkdGggKiBNQVhfUkFUSU8gfHxcbiAgICAgIGJveEhlaWdodCA+IG92bWFwSGVpZ2h0ICogTUFYX1JBVElPXG4gICAgKSB7XG4gICAgICB0aGlzLnJlc2V0RXh0ZW50XygpO1xuICAgIH0gZWxzZSBpZiAoIWNvbnRhaW5zRXh0ZW50KG92ZXh0ZW50LCBleHRlbnQpKSB7XG4gICAgICB0aGlzLnJlY2VudGVyXygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCB0aGUgb3ZlcnZpZXcgbWFwIGV4dGVudCB0byBoYWxmIGNhbGN1bGF0ZWQgbWluIGFuZCBtYXggcmF0aW8gdGltZXNcbiAgICogdGhlIGV4dGVudCBvZiB0aGUgbWFpbiBtYXAuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZXNldEV4dGVudF8oKSB7XG4gICAgaWYgKE1BWF9SQVRJTyA9PT0gMCB8fCBNSU5fUkFUSU8gPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBtYXAgPSB0aGlzLmdldE1hcCgpO1xuICAgIGNvbnN0IG92bWFwID0gdGhpcy5vdm1hcF87XG5cbiAgICBjb25zdCBtYXBTaXplID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9ICovIChtYXAuZ2V0U2l6ZSgpKTtcblxuICAgIGNvbnN0IHZpZXcgPSBtYXAuZ2V0VmlldygpO1xuICAgIGNvbnN0IGV4dGVudCA9IHZpZXcuY2FsY3VsYXRlRXh0ZW50SW50ZXJuYWwobWFwU2l6ZSk7XG5cbiAgICBjb25zdCBvdnZpZXcgPSBvdm1hcC5nZXRWaWV3KCk7XG5cbiAgICAvLyBnZXQgaG93IG1hbnkgdGltZXMgdGhlIGN1cnJlbnQgbWFwIG92ZXJ2aWV3IGNvdWxkIGhvbGQgZGlmZmVyZW50XG4gICAgLy8gYm94IHNpemVzIHVzaW5nIHRoZSBtaW4gYW5kIG1heCByYXRpbywgcGljayB0aGUgc3RlcCBpbiB0aGUgbWlkZGxlIHVzZWRcbiAgICAvLyB0byBjYWxjdWxhdGUgdGhlIGV4dGVudCBmcm9tIHRoZSBtYWluIG1hcCB0byBzZXQgaXQgdG8gdGhlIG92ZXJ2aWV3IG1hcCxcbiAgICBjb25zdCBzdGVwcyA9IE1hdGgubG9nKE1BWF9SQVRJTyAvIE1JTl9SQVRJTykgLyBNYXRoLkxOMjtcbiAgICBjb25zdCByYXRpbyA9IDEgLyAoTWF0aC5wb3coMiwgc3RlcHMgLyAyKSAqIE1JTl9SQVRJTyk7XG4gICAgc2NhbGVGcm9tQ2VudGVyKGV4dGVudCwgcmF0aW8pO1xuICAgIG92dmlldy5maXRJbnRlcm5hbChwb2x5Z29uRnJvbUV4dGVudChleHRlbnQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNlbnRlciBvZiB0aGUgb3ZlcnZpZXcgbWFwIHRvIHRoZSBtYXAgY2VudGVyIHdpdGhvdXQgY2hhbmdpbmcgaXRzXG4gICAqIHJlc29sdXRpb24uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZWNlbnRlcl8oKSB7XG4gICAgY29uc3QgbWFwID0gdGhpcy5nZXRNYXAoKTtcbiAgICBjb25zdCBvdm1hcCA9IHRoaXMub3ZtYXBfO1xuXG4gICAgY29uc3QgdmlldyA9IG1hcC5nZXRWaWV3KCk7XG5cbiAgICBjb25zdCBvdnZpZXcgPSBvdm1hcC5nZXRWaWV3KCk7XG5cbiAgICBvdnZpZXcuc2V0Q2VudGVySW50ZXJuYWwodmlldy5nZXRDZW50ZXJJbnRlcm5hbCgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGJveCB1c2luZyB0aGUgbWFpbiBtYXAgZXh0ZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB1cGRhdGVCb3hfKCkge1xuICAgIGNvbnN0IG1hcCA9IHRoaXMuZ2V0TWFwKCk7XG4gICAgY29uc3Qgb3ZtYXAgPSB0aGlzLm92bWFwXztcblxuICAgIGlmICghbWFwLmlzUmVuZGVyZWQoKSB8fCAhb3ZtYXAuaXNSZW5kZXJlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbWFwU2l6ZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSAqLyAobWFwLmdldFNpemUoKSk7XG5cbiAgICBjb25zdCB2aWV3ID0gbWFwLmdldFZpZXcoKTtcblxuICAgIGNvbnN0IG92dmlldyA9IG92bWFwLmdldFZpZXcoKTtcblxuICAgIGNvbnN0IHJvdGF0aW9uID0gdGhpcy5yb3RhdGVXaXRoVmlld18gPyAwIDogLXZpZXcuZ2V0Um90YXRpb24oKTtcblxuICAgIGNvbnN0IG92ZXJsYXkgPSB0aGlzLmJveE92ZXJsYXlfO1xuICAgIGNvbnN0IGJveCA9IHRoaXMuYm94T3ZlcmxheV8uZ2V0RWxlbWVudCgpO1xuICAgIGNvbnN0IGNlbnRlciA9IHZpZXcuZ2V0Q2VudGVySW50ZXJuYWwoKTtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdmlldy5nZXRSZXNvbHV0aW9uKCk7XG4gICAgY29uc3Qgb3ZyZXNvbHV0aW9uID0gb3Z2aWV3LmdldFJlc29sdXRpb24oKTtcbiAgICBjb25zdCB3aWR0aCA9IChtYXBTaXplWzBdICogcmVzb2x1dGlvbikgLyBvdnJlc29sdXRpb247XG4gICAgY29uc3QgaGVpZ2h0ID0gKG1hcFNpemVbMV0gKiByZXNvbHV0aW9uKSAvIG92cmVzb2x1dGlvbjtcblxuICAgIC8vIHNldCBwb3NpdGlvbiB1c2luZyBjZW50ZXIgY29vcmRpbmF0ZXNcbiAgICBvdmVybGF5LnNldFBvc2l0aW9uKGNlbnRlcik7XG5cbiAgICAvLyBzZXQgYm94IHNpemUgY2FsY3VsYXRlZCBmcm9tIG1hcCBleHRlbnQgc2l6ZSBhbmQgb3ZlcnZpZXcgbWFwIHJlc29sdXRpb25cbiAgICBpZiAoYm94KSB7XG4gICAgICBib3guc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgICBib3guc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9ICdyb3RhdGUoJyArIHJvdGF0aW9uICsgJ3JhZCknO1xuICAgICAgYm94LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHVwZGF0ZUJveEFmdGVyT3ZtYXBJc1JlbmRlcmVkXygpIHtcbiAgICBpZiAodGhpcy5vdm1hcFBvc3RyZW5kZXJLZXlfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMub3ZtYXBQb3N0cmVuZGVyS2V5XyA9IGxpc3Rlbk9uY2UoXG4gICAgICB0aGlzLm92bWFwXyxcbiAgICAgIE1hcEV2ZW50VHlwZS5QT1NUUkVOREVSLFxuICAgICAgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm92bWFwUG9zdHJlbmRlcktleV87XG4gICAgICAgIHRoaXMudXBkYXRlQm94XygpO1xuICAgICAgfSxcbiAgICAgIHRoaXMsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50IFRoZSBldmVudCB0byBoYW5kbGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUNsaWNrXyhldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy5oYW5kbGVUb2dnbGVfKCk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZVRvZ2dsZV8oKSB7XG4gICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoQ0xBU1NfQ09MTEFQU0VEKTtcbiAgICBpZiAodGhpcy5jb2xsYXBzZWRfKSB7XG4gICAgICByZXBsYWNlTm9kZSh0aGlzLmNvbGxhcHNlTGFiZWxfLCB0aGlzLmxhYmVsXyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcGxhY2VOb2RlKHRoaXMubGFiZWxfLCB0aGlzLmNvbGxhcHNlTGFiZWxfKTtcbiAgICB9XG4gICAgdGhpcy5jb2xsYXBzZWRfID0gIXRoaXMuY29sbGFwc2VkXztcblxuICAgIC8vIG1hbmFnZSBvdmVydmlldyBtYXAgaWYgaXQgaGFkIG5vdCBiZWVuIHJlbmRlcmVkIGJlZm9yZSBhbmQgY29udHJvbFxuICAgIC8vIGlzIGV4cGFuZGVkXG4gICAgY29uc3Qgb3ZtYXAgPSB0aGlzLm92bWFwXztcbiAgICBpZiAoIXRoaXMuY29sbGFwc2VkXykge1xuICAgICAgaWYgKG92bWFwLmlzUmVuZGVyZWQoKSkge1xuICAgICAgICB0aGlzLnZpZXdFeHRlbnRfID0gdW5kZWZpbmVkO1xuICAgICAgICBvdm1hcC5yZW5kZXIoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgb3ZtYXAudXBkYXRlU2l6ZSgpO1xuICAgICAgdGhpcy5yZXNldEV4dGVudF8oKTtcbiAgICAgIHRoaXMudXBkYXRlQm94QWZ0ZXJPdm1hcElzUmVuZGVyZWRfKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIG92ZXJ2aWV3IG1hcCBpcyBjb2xsYXBzaWJsZSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHdpZGdldCBpcyBjb2xsYXBzaWJsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0Q29sbGFwc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGFwc2libGVfO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB3aGV0aGVyIHRoZSBvdmVydmlldyBtYXAgc2hvdWxkIGJlIGNvbGxhcHNpYmxlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNvbGxhcHNpYmxlIFRydWUgaWYgdGhlIHdpZGdldCBpcyBjb2xsYXBzaWJsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0Q29sbGFwc2libGUoY29sbGFwc2libGUpIHtcbiAgICBpZiAodGhpcy5jb2xsYXBzaWJsZV8gPT09IGNvbGxhcHNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY29sbGFwc2libGVfID0gY29sbGFwc2libGU7XG4gICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoJ29sLXVuY29sbGFwc2libGUnKTtcbiAgICBpZiAoIWNvbGxhcHNpYmxlICYmIHRoaXMuY29sbGFwc2VkXykge1xuICAgICAgdGhpcy5oYW5kbGVUb2dnbGVfKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbGxhcHNlIG9yIGV4cGFuZCB0aGUgb3ZlcnZpZXcgbWFwIGFjY29yZGluZyB0byB0aGUgcGFzc2VkIHBhcmFtZXRlci4gV2lsbFxuICAgKiBub3QgZG8gYW55dGhpbmcgaWYgdGhlIG92ZXJ2aWV3IG1hcCBpc24ndCBjb2xsYXBzaWJsZSBvciBpZiB0aGUgY3VycmVudFxuICAgKiBjb2xsYXBzZWQgc3RhdGUgaXMgYWxyZWFkeSB0aGUgb25lIHJlcXVlc3RlZC5cbiAgICogQHBhcmFtIHtib29sZWFufSBjb2xsYXBzZWQgVHJ1ZSBpZiB0aGUgd2lkZ2V0IGlzIGNvbGxhcHNlZC5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0Q29sbGFwc2VkKGNvbGxhcHNlZCkge1xuICAgIGlmICghdGhpcy5jb2xsYXBzaWJsZV8gfHwgdGhpcy5jb2xsYXBzZWRfID09PSBjb2xsYXBzZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5oYW5kbGVUb2dnbGVfKCk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIGlmIHRoZSBvdmVydmlldyBtYXAgaXMgY29sbGFwc2VkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgb3ZlcnZpZXcgbWFwIGlzIGNvbGxhcHNlZC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0Q29sbGFwc2VkKCkge1xuICAgIHJldHVybiB0aGlzLmNvbGxhcHNlZF87XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgb3ZlcnZpZXcgbWFwIHZpZXcgY2FuIHJvdGF0ZSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGNvbnRyb2wgdmlldyBjYW4gcm90YXRlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRSb3RhdGVXaXRoVmlldygpIHtcbiAgICByZXR1cm4gdGhpcy5yb3RhdGVXaXRoVmlld187XG4gIH1cblxuICAvKipcbiAgICogU2V0IHdoZXRoZXIgdGhlIG92ZXJ2aWV3IG1hcCB2aWV3IHNob3VsZCByb3RhdGUgd2l0aCB0aGUgbWFpbiBtYXAgdmlldy5cbiAgICogQHBhcmFtIHtib29sZWFufSByb3RhdGVXaXRoVmlldyBUcnVlIGlmIHRoZSBjb250cm9sIHZpZXcgc2hvdWxkIHJvdGF0ZS5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0Um90YXRlV2l0aFZpZXcocm90YXRlV2l0aFZpZXcpIHtcbiAgICBpZiAodGhpcy5yb3RhdGVXaXRoVmlld18gPT09IHJvdGF0ZVdpdGhWaWV3KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucm90YXRlV2l0aFZpZXdfID0gcm90YXRlV2l0aFZpZXc7XG4gICAgaWYgKHRoaXMuZ2V0TWFwKCkuZ2V0VmlldygpLmdldFJvdGF0aW9uKCkgIT09IDApIHtcbiAgICAgIGlmICh0aGlzLnJvdGF0ZVdpdGhWaWV3Xykge1xuICAgICAgICB0aGlzLmhhbmRsZVJvdGF0aW9uQ2hhbmdlZF8oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub3ZtYXBfLmdldFZpZXcoKS5zZXRSb3RhdGlvbigwKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudmlld0V4dGVudF8gPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLnZhbGlkYXRlRXh0ZW50XygpO1xuICAgICAgdGhpcy51cGRhdGVCb3hfKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgb3ZlcnZpZXcgbWFwLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuZGVmYXVsdH0gT3ZlcnZpZXcgbWFwLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRPdmVydmlld01hcCgpIHtcbiAgICByZXR1cm4gdGhpcy5vdm1hcF87XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBvdmVydmlldyBtYXAgZWxlbWVudC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBFdmVudCBNYXAgZXZlbnQuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgcmVuZGVyKG1hcEV2ZW50KSB7XG4gICAgdGhpcy52YWxpZGF0ZUV4dGVudF8oKTtcbiAgICB0aGlzLnVwZGF0ZUJveF8oKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBPdmVydmlld01hcDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ol/control/OverviewMap.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ol/control/ZoomSlider.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/control/ZoomSlider.js ***!
  \***********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Control_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Control.js */ \"(app-pages-browser)/./node_modules/ol/control/Control.js\");\n/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/EventType.js */ \"(app-pages-browser)/./node_modules/ol/events/EventType.js\");\n/* harmony import */ var _pointer_EventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../pointer/EventType.js */ \"(app-pages-browser)/./node_modules/ol/pointer/EventType.js\");\n/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../css.js */ \"(app-pages-browser)/./node_modules/ol/css.js\");\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../math.js */ \"(app-pages-browser)/./node_modules/ol/math.js\");\n/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../easing.js */ \"(app-pages-browser)/./node_modules/ol/easing.js\");\n/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../events.js */ \"(app-pages-browser)/./node_modules/ol/events.js\");\n/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events/Event.js */ \"(app-pages-browser)/./node_modules/ol/events/Event.js\");\n/**\n * @module ol/control/ZoomSlider\n */\n\n\n\n\n\n\n\n\n\n\n/**\n * The enum for available directions.\n *\n * @enum {number}\n */\nconst Direction = {\n  VERTICAL: 0,\n  HORIZONTAL: 1,\n};\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-zoomslider'] CSS class name.\n * @property {number} [duration=200] Animation duration in milliseconds.\n * @property {function(import(\"../MapEvent.js\").default):void} [render] Function called when the control\n * should be re-rendered. This is called in a `requestAnimationFrame` callback.\n * @property {HTMLElement|string} [target] Specify a target if you want the control to be\n * rendered outside of the map's viewport.\n */\n\n/**\n * @classdesc\n * A slider type of control for zooming.\n *\n * Example:\n *\n *     map.addControl(new ZoomSlider());\n *\n * @api\n */\nclass ZoomSlider extends _Control_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  /**\n   * @param {Options} [options] Zoom slider options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super({\n      target: options.target,\n      element: document.createElement('div'),\n      render: options.render,\n    });\n\n    /**\n     * @type {!Array<import(\"../events.js\").EventsKey>}\n     * @private\n     */\n    this.dragListenerKeys_ = [];\n\n    /**\n     * Will hold the current resolution of the view.\n     *\n     * @type {number|undefined}\n     * @private\n     */\n    this.currentResolution_ = undefined;\n\n    /**\n     * The direction of the slider. Will be determined from actual display of the\n     * container and defaults to Direction.VERTICAL.\n     *\n     * @type {Direction}\n     * @private\n     */\n    this.direction_ = Direction.VERTICAL;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.dragging_;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.heightLimit_ = 0;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.widthLimit_ = 0;\n\n    /**\n     * @type {number|undefined}\n     * @private\n     */\n    this.startX_;\n\n    /**\n     * @type {number|undefined}\n     * @private\n     */\n    this.startY_;\n\n    /**\n     * The calculated thumb size (border box plus margins).  Set when initSlider_\n     * is called.\n     * @type {import(\"../size.js\").Size}\n     * @private\n     */\n    this.thumbSize_ = null;\n\n    /**\n     * Whether the slider is initialized.\n     * @type {boolean}\n     * @private\n     */\n    this.sliderInitialized_ = false;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 200;\n\n    const className =\n      options.className !== undefined ? options.className : 'ol-zoomslider';\n    const thumbElement = document.createElement('button');\n    thumbElement.setAttribute('type', 'button');\n    thumbElement.className = className + '-thumb ' + _css_js__WEBPACK_IMPORTED_MODULE_1__.CLASS_UNSELECTABLE;\n    const containerElement = this.element;\n    containerElement.className =\n      className + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_1__.CLASS_UNSELECTABLE + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_1__.CLASS_CONTROL;\n    containerElement.appendChild(thumbElement);\n\n    containerElement.addEventListener(\n      _pointer_EventType_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].POINTERDOWN,\n      this.handleDraggerStart_.bind(this),\n      false,\n    );\n    containerElement.addEventListener(\n      _pointer_EventType_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].POINTERMOVE,\n      this.handleDraggerDrag_.bind(this),\n      false,\n    );\n    containerElement.addEventListener(\n      _pointer_EventType_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].POINTERUP,\n      this.handleDraggerEnd_.bind(this),\n      false,\n    );\n\n    containerElement.addEventListener(\n      _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].CLICK,\n      this.handleContainerClick_.bind(this),\n      false,\n    );\n    thumbElement.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].CLICK, _events_Event_js__WEBPACK_IMPORTED_MODULE_4__.stopPropagation, false);\n  }\n\n  /**\n   * Remove the control from its current map and attach it to the new map.\n   * Pass `null` to just remove the control from the current map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default|null} map Map.\n   * @api\n   */\n  setMap(map) {\n    super.setMap(map);\n    if (map) {\n      map.render();\n    }\n  }\n\n  /**\n   * Initializes the slider element. This will determine and set this controls\n   * direction_ and also constrain the dragging of the thumb to always be within\n   * the bounds of the container.\n   *\n   * @return {boolean} Initialization successful\n   * @private\n   */\n  initSlider_() {\n    const container = this.element;\n    let containerWidth = container.offsetWidth;\n    let containerHeight = container.offsetHeight;\n    if (containerWidth === 0 && containerHeight === 0) {\n      return (this.sliderInitialized_ = false);\n    }\n\n    const containerStyle = getComputedStyle(container);\n    containerWidth -=\n      parseFloat(containerStyle['paddingRight']) +\n      parseFloat(containerStyle['paddingLeft']);\n    containerHeight -=\n      parseFloat(containerStyle['paddingTop']) +\n      parseFloat(containerStyle['paddingBottom']);\n    const thumb = /** @type {HTMLElement} */ (container.firstElementChild);\n    const thumbStyle = getComputedStyle(thumb);\n    const thumbWidth =\n      thumb.offsetWidth +\n      parseFloat(thumbStyle['marginRight']) +\n      parseFloat(thumbStyle['marginLeft']);\n    const thumbHeight =\n      thumb.offsetHeight +\n      parseFloat(thumbStyle['marginTop']) +\n      parseFloat(thumbStyle['marginBottom']);\n    this.thumbSize_ = [thumbWidth, thumbHeight];\n\n    if (containerWidth > containerHeight) {\n      this.direction_ = Direction.HORIZONTAL;\n      this.widthLimit_ = containerWidth - thumbWidth;\n    } else {\n      this.direction_ = Direction.VERTICAL;\n      this.heightLimit_ = containerHeight - thumbHeight;\n    }\n    return (this.sliderInitialized_ = true);\n  }\n\n  /**\n   * @param {PointerEvent} event The browser event to handle.\n   * @private\n   */\n  handleContainerClick_(event) {\n    const view = this.getMap().getView();\n\n    const relativePosition = this.getRelativePosition_(\n      event.offsetX - this.thumbSize_[0] / 2,\n      event.offsetY - this.thumbSize_[1] / 2,\n    );\n\n    const resolution = this.getResolutionForPosition_(relativePosition);\n    const zoom = view.getConstrainedZoom(view.getZoomForResolution(resolution));\n\n    view.animateInternal({\n      zoom: zoom,\n      duration: this.duration_,\n      easing: _easing_js__WEBPACK_IMPORTED_MODULE_5__.easeOut,\n    });\n  }\n\n  /**\n   * Handle dragger start events.\n   * @param {PointerEvent} event The drag event.\n   * @private\n   */\n  handleDraggerStart_(event) {\n    if (!this.dragging_ && event.target === this.element.firstElementChild) {\n      const element = /** @type {HTMLElement} */ (\n        this.element.firstElementChild\n      );\n      this.getMap().getView().beginInteraction();\n      this.startX_ = event.clientX - parseFloat(element.style.left);\n      this.startY_ = event.clientY - parseFloat(element.style.top);\n      this.dragging_ = true;\n\n      if (this.dragListenerKeys_.length === 0) {\n        const drag = this.handleDraggerDrag_;\n        const end = this.handleDraggerEnd_;\n        const doc = this.getMap().getOwnerDocument();\n        this.dragListenerKeys_.push(\n          (0,_events_js__WEBPACK_IMPORTED_MODULE_6__.listen)(doc, _pointer_EventType_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].POINTERMOVE, drag, this),\n          (0,_events_js__WEBPACK_IMPORTED_MODULE_6__.listen)(doc, _pointer_EventType_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].POINTERUP, end, this),\n        );\n      }\n    }\n  }\n\n  /**\n   * Handle dragger drag events.\n   *\n   * @param {PointerEvent} event The drag event.\n   * @private\n   */\n  handleDraggerDrag_(event) {\n    if (this.dragging_) {\n      const deltaX = event.clientX - this.startX_;\n      const deltaY = event.clientY - this.startY_;\n      const relativePosition = this.getRelativePosition_(deltaX, deltaY);\n      this.currentResolution_ =\n        this.getResolutionForPosition_(relativePosition);\n      this.getMap().getView().setResolution(this.currentResolution_);\n    }\n  }\n\n  /**\n   * Handle dragger end events.\n   * @param {PointerEvent} event The drag event.\n   * @private\n   */\n  handleDraggerEnd_(event) {\n    if (this.dragging_) {\n      const view = this.getMap().getView();\n      view.endInteraction();\n\n      this.dragging_ = false;\n      this.startX_ = undefined;\n      this.startY_ = undefined;\n      this.dragListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_6__.unlistenByKey);\n      this.dragListenerKeys_.length = 0;\n    }\n  }\n\n  /**\n   * Positions the thumb inside its container according to the given resolution.\n   *\n   * @param {number} res The res.\n   * @private\n   */\n  setThumbPosition_(res) {\n    const position = this.getPositionForResolution_(res);\n    const thumb = /** @type {HTMLElement} */ (this.element.firstElementChild);\n\n    if (this.direction_ == Direction.HORIZONTAL) {\n      thumb.style.left = this.widthLimit_ * position + 'px';\n    } else {\n      thumb.style.top = this.heightLimit_ * position + 'px';\n    }\n  }\n\n  /**\n   * Calculates the relative position of the thumb given x and y offsets.  The\n   * relative position scales from 0 to 1.  The x and y offsets are assumed to be\n   * in pixel units within the dragger limits.\n   *\n   * @param {number} x Pixel position relative to the left of the slider.\n   * @param {number} y Pixel position relative to the top of the slider.\n   * @return {number} The relative position of the thumb.\n   * @private\n   */\n  getRelativePosition_(x, y) {\n    let amount;\n    if (this.direction_ === Direction.HORIZONTAL) {\n      amount = x / this.widthLimit_;\n    } else {\n      amount = y / this.heightLimit_;\n    }\n    return (0,_math_js__WEBPACK_IMPORTED_MODULE_7__.clamp)(amount, 0, 1);\n  }\n\n  /**\n   * Calculates the corresponding resolution of the thumb given its relative\n   * position (where 0 is the minimum and 1 is the maximum).\n   *\n   * @param {number} position The relative position of the thumb.\n   * @return {number} The corresponding resolution.\n   * @private\n   */\n  getResolutionForPosition_(position) {\n    const fn = this.getMap().getView().getResolutionForValueFunction();\n    return fn(1 - position);\n  }\n\n  /**\n   * Determines the relative position of the slider for the given resolution.  A\n   * relative position of 0 corresponds to the minimum view resolution.  A\n   * relative position of 1 corresponds to the maximum view resolution.\n   *\n   * @param {number} res The resolution.\n   * @return {number} The relative position value (between 0 and 1).\n   * @private\n   */\n  getPositionForResolution_(res) {\n    const fn = this.getMap().getView().getValueForResolutionFunction();\n    return (0,_math_js__WEBPACK_IMPORTED_MODULE_7__.clamp)(1 - fn(res), 0, 1);\n  }\n\n  /**\n   * Update the zoomslider element.\n   * @param {import(\"../MapEvent.js\").default} mapEvent Map event.\n   * @override\n   */\n  render(mapEvent) {\n    if (!mapEvent.frameState) {\n      return;\n    }\n    if (!this.sliderInitialized_ && !this.initSlider_()) {\n      return;\n    }\n    const res = mapEvent.frameState.viewState.resolution;\n    this.currentResolution_ = res;\n    this.setThumbPosition_(res);\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (ZoomSlider);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vbC9jb250cm9sL1pvb21TbGlkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBOztBQUVtQztBQUNZO0FBQ1E7QUFDSztBQUMzQjtBQUNJO0FBQ2M7QUFDQTs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLGlEQUFpRDtBQUMvRDtBQUNBLGNBQWMsb0JBQW9CO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsbURBQU87QUFDaEM7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCx1REFBa0I7QUFDdkU7QUFDQTtBQUNBLHdCQUF3Qix1REFBa0IsU0FBUyxrREFBYTtBQUNoRTs7QUFFQTtBQUNBLE1BQU0sNkRBQWdCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSw2REFBZ0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDZEQUFnQjtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLDREQUFTO0FBQ2Y7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDREQUFTLFFBQVEsNkRBQWU7QUFDbEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0NBQWtDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsYUFBYTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsK0NBQU87QUFDckIsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsYUFBYTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0RBQU0sTUFBTSw2REFBZ0I7QUFDdEMsVUFBVSxrREFBTSxNQUFNLDZEQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxxREFBYTtBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGFBQWE7O0FBRTFDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFdBQVcsK0NBQUs7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsK0NBQUs7QUFDaEI7O0FBRUE7QUFDQTtBQUNBLGFBQWEsa0NBQWtDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0RBQWUsVUFBVSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9vbC9jb250cm9sL1pvb21TbGlkZXIuanM/MDIwNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvY29udHJvbC9ab29tU2xpZGVyXG4gKi9cblxuaW1wb3J0IENvbnRyb2wgZnJvbSAnLi9Db250cm9sLmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgUG9pbnRlckV2ZW50VHlwZSBmcm9tICcuLi9wb2ludGVyL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQge0NMQVNTX0NPTlRST0wsIENMQVNTX1VOU0VMRUNUQUJMRX0gZnJvbSAnLi4vY3NzLmpzJztcbmltcG9ydCB7Y2xhbXB9IGZyb20gJy4uL21hdGguanMnO1xuaW1wb3J0IHtlYXNlT3V0fSBmcm9tICcuLi9lYXNpbmcuanMnO1xuaW1wb3J0IHtsaXN0ZW4sIHVubGlzdGVuQnlLZXl9IGZyb20gJy4uL2V2ZW50cy5qcyc7XG5pbXBvcnQge3N0b3BQcm9wYWdhdGlvbn0gZnJvbSAnLi4vZXZlbnRzL0V2ZW50LmpzJztcblxuLyoqXG4gKiBUaGUgZW51bSBmb3IgYXZhaWxhYmxlIGRpcmVjdGlvbnMuXG4gKlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuY29uc3QgRGlyZWN0aW9uID0ge1xuICBWRVJUSUNBTDogMCxcbiAgSE9SSVpPTlRBTDogMSxcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzc05hbWU9J29sLXpvb21zbGlkZXInXSBDU1MgY2xhc3MgbmFtZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHVyYXRpb249MjAwXSBBbmltYXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbihpbXBvcnQoXCIuLi9NYXBFdmVudC5qc1wiKS5kZWZhdWx0KTp2b2lkfSBbcmVuZGVyXSBGdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgY29udHJvbFxuICogc2hvdWxkIGJlIHJlLXJlbmRlcmVkLiBUaGlzIGlzIGNhbGxlZCBpbiBhIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIGNhbGxiYWNrLlxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudHxzdHJpbmd9IFt0YXJnZXRdIFNwZWNpZnkgYSB0YXJnZXQgaWYgeW91IHdhbnQgdGhlIGNvbnRyb2wgdG8gYmVcbiAqIHJlbmRlcmVkIG91dHNpZGUgb2YgdGhlIG1hcCdzIHZpZXdwb3J0LlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQSBzbGlkZXIgdHlwZSBvZiBjb250cm9sIGZvciB6b29taW5nLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIG1hcC5hZGRDb250cm9sKG5ldyBab29tU2xpZGVyKCkpO1xuICpcbiAqIEBhcGlcbiAqL1xuY2xhc3MgWm9vbVNsaWRlciBleHRlbmRzIENvbnRyb2wge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gWm9vbSBzbGlkZXIgb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyA/IG9wdGlvbnMgOiB7fTtcblxuICAgIHN1cGVyKHtcbiAgICAgIHRhcmdldDogb3B0aW9ucy50YXJnZXQsXG4gICAgICBlbGVtZW50OiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgIHJlbmRlcjogb3B0aW9ucy5yZW5kZXIsXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7IUFycmF5PGltcG9ydChcIi4uL2V2ZW50cy5qc1wiKS5FdmVudHNLZXk+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5kcmFnTGlzdGVuZXJLZXlzXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogV2lsbCBob2xkIHRoZSBjdXJyZW50IHJlc29sdXRpb24gb2YgdGhlIHZpZXcuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuY3VycmVudFJlc29sdXRpb25fID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRpcmVjdGlvbiBvZiB0aGUgc2xpZGVyLiBXaWxsIGJlIGRldGVybWluZWQgZnJvbSBhY3R1YWwgZGlzcGxheSBvZiB0aGVcbiAgICAgKiBjb250YWluZXIgYW5kIGRlZmF1bHRzIHRvIERpcmVjdGlvbi5WRVJUSUNBTC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtEaXJlY3Rpb259XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmRpcmVjdGlvbl8gPSBEaXJlY3Rpb24uVkVSVElDQUw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZHJhZ2dpbmdfO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaGVpZ2h0TGltaXRfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLndpZHRoTGltaXRfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5zdGFydFhfO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnN0YXJ0WV87XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2FsY3VsYXRlZCB0aHVtYiBzaXplIChib3JkZXIgYm94IHBsdXMgbWFyZ2lucykuICBTZXQgd2hlbiBpbml0U2xpZGVyX1xuICAgICAqIGlzIGNhbGxlZC5cbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy50aHVtYlNpemVfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIHNsaWRlciBpcyBpbml0aWFsaXplZC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuc2xpZGVySW5pdGlhbGl6ZWRfID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5kdXJhdGlvbl8gPSBvcHRpb25zLmR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmR1cmF0aW9uIDogMjAwO1xuXG4gICAgY29uc3QgY2xhc3NOYW1lID1cbiAgICAgIG9wdGlvbnMuY2xhc3NOYW1lICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNsYXNzTmFtZSA6ICdvbC16b29tc2xpZGVyJztcbiAgICBjb25zdCB0aHVtYkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICB0aHVtYkVsZW1lbnQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ2J1dHRvbicpO1xuICAgIHRodW1iRWxlbWVudC5jbGFzc05hbWUgPSBjbGFzc05hbWUgKyAnLXRodW1iICcgKyBDTEFTU19VTlNFTEVDVEFCTEU7XG4gICAgY29uc3QgY29udGFpbmVyRWxlbWVudCA9IHRoaXMuZWxlbWVudDtcbiAgICBjb250YWluZXJFbGVtZW50LmNsYXNzTmFtZSA9XG4gICAgICBjbGFzc05hbWUgKyAnICcgKyBDTEFTU19VTlNFTEVDVEFCTEUgKyAnICcgKyBDTEFTU19DT05UUk9MO1xuICAgIGNvbnRhaW5lckVsZW1lbnQuYXBwZW5kQ2hpbGQodGh1bWJFbGVtZW50KTtcblxuICAgIGNvbnRhaW5lckVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIFBvaW50ZXJFdmVudFR5cGUuUE9JTlRFUkRPV04sXG4gICAgICB0aGlzLmhhbmRsZURyYWdnZXJTdGFydF8uYmluZCh0aGlzKSxcbiAgICAgIGZhbHNlLFxuICAgICk7XG4gICAgY29udGFpbmVyRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgUG9pbnRlckV2ZW50VHlwZS5QT0lOVEVSTU9WRSxcbiAgICAgIHRoaXMuaGFuZGxlRHJhZ2dlckRyYWdfLmJpbmQodGhpcyksXG4gICAgICBmYWxzZSxcbiAgICApO1xuICAgIGNvbnRhaW5lckVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIFBvaW50ZXJFdmVudFR5cGUuUE9JTlRFUlVQLFxuICAgICAgdGhpcy5oYW5kbGVEcmFnZ2VyRW5kXy5iaW5kKHRoaXMpLFxuICAgICAgZmFsc2UsXG4gICAgKTtcblxuICAgIGNvbnRhaW5lckVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIEV2ZW50VHlwZS5DTElDSyxcbiAgICAgIHRoaXMuaGFuZGxlQ29udGFpbmVyQ2xpY2tfLmJpbmQodGhpcyksXG4gICAgICBmYWxzZSxcbiAgICApO1xuICAgIHRodW1iRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKEV2ZW50VHlwZS5DTElDSywgc3RvcFByb3BhZ2F0aW9uLCBmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBjb250cm9sIGZyb20gaXRzIGN1cnJlbnQgbWFwIGFuZCBhdHRhY2ggaXQgdG8gdGhlIG5ldyBtYXAuXG4gICAqIFBhc3MgYG51bGxgIHRvIGp1c3QgcmVtb3ZlIHRoZSBjb250cm9sIGZyb20gdGhlIGN1cnJlbnQgbWFwLlxuICAgKiBTdWJjbGFzc2VzIG1heSBzZXQgdXAgZXZlbnQgaGFuZGxlcnMgdG8gZ2V0IG5vdGlmaWVkIGFib3V0IGNoYW5nZXMgdG9cbiAgICogdGhlIG1hcCBoZXJlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcC5qc1wiKS5kZWZhdWx0fG51bGx9IG1hcCBNYXAuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldE1hcChtYXApIHtcbiAgICBzdXBlci5zZXRNYXAobWFwKTtcbiAgICBpZiAobWFwKSB7XG4gICAgICBtYXAucmVuZGVyKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBzbGlkZXIgZWxlbWVudC4gVGhpcyB3aWxsIGRldGVybWluZSBhbmQgc2V0IHRoaXMgY29udHJvbHNcbiAgICogZGlyZWN0aW9uXyBhbmQgYWxzbyBjb25zdHJhaW4gdGhlIGRyYWdnaW5nIG9mIHRoZSB0aHVtYiB0byBhbHdheXMgYmUgd2l0aGluXG4gICAqIHRoZSBib3VuZHMgb2YgdGhlIGNvbnRhaW5lci5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSW5pdGlhbGl6YXRpb24gc3VjY2Vzc2Z1bFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaW5pdFNsaWRlcl8oKSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5lbGVtZW50O1xuICAgIGxldCBjb250YWluZXJXaWR0aCA9IGNvbnRhaW5lci5vZmZzZXRXaWR0aDtcbiAgICBsZXQgY29udGFpbmVySGVpZ2h0ID0gY29udGFpbmVyLm9mZnNldEhlaWdodDtcbiAgICBpZiAoY29udGFpbmVyV2lkdGggPT09IDAgJiYgY29udGFpbmVySGVpZ2h0ID09PSAwKSB7XG4gICAgICByZXR1cm4gKHRoaXMuc2xpZGVySW5pdGlhbGl6ZWRfID0gZmFsc2UpO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbnRhaW5lclN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShjb250YWluZXIpO1xuICAgIGNvbnRhaW5lcldpZHRoIC09XG4gICAgICBwYXJzZUZsb2F0KGNvbnRhaW5lclN0eWxlWydwYWRkaW5nUmlnaHQnXSkgK1xuICAgICAgcGFyc2VGbG9hdChjb250YWluZXJTdHlsZVsncGFkZGluZ0xlZnQnXSk7XG4gICAgY29udGFpbmVySGVpZ2h0IC09XG4gICAgICBwYXJzZUZsb2F0KGNvbnRhaW5lclN0eWxlWydwYWRkaW5nVG9wJ10pICtcbiAgICAgIHBhcnNlRmxvYXQoY29udGFpbmVyU3R5bGVbJ3BhZGRpbmdCb3R0b20nXSk7XG4gICAgY29uc3QgdGh1bWIgPSAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyAoY29udGFpbmVyLmZpcnN0RWxlbWVudENoaWxkKTtcbiAgICBjb25zdCB0aHVtYlN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aHVtYik7XG4gICAgY29uc3QgdGh1bWJXaWR0aCA9XG4gICAgICB0aHVtYi5vZmZzZXRXaWR0aCArXG4gICAgICBwYXJzZUZsb2F0KHRodW1iU3R5bGVbJ21hcmdpblJpZ2h0J10pICtcbiAgICAgIHBhcnNlRmxvYXQodGh1bWJTdHlsZVsnbWFyZ2luTGVmdCddKTtcbiAgICBjb25zdCB0aHVtYkhlaWdodCA9XG4gICAgICB0aHVtYi5vZmZzZXRIZWlnaHQgK1xuICAgICAgcGFyc2VGbG9hdCh0aHVtYlN0eWxlWydtYXJnaW5Ub3AnXSkgK1xuICAgICAgcGFyc2VGbG9hdCh0aHVtYlN0eWxlWydtYXJnaW5Cb3R0b20nXSk7XG4gICAgdGhpcy50aHVtYlNpemVfID0gW3RodW1iV2lkdGgsIHRodW1iSGVpZ2h0XTtcblxuICAgIGlmIChjb250YWluZXJXaWR0aCA+IGNvbnRhaW5lckhlaWdodCkge1xuICAgICAgdGhpcy5kaXJlY3Rpb25fID0gRGlyZWN0aW9uLkhPUklaT05UQUw7XG4gICAgICB0aGlzLndpZHRoTGltaXRfID0gY29udGFpbmVyV2lkdGggLSB0aHVtYldpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRpcmVjdGlvbl8gPSBEaXJlY3Rpb24uVkVSVElDQUw7XG4gICAgICB0aGlzLmhlaWdodExpbWl0XyA9IGNvbnRhaW5lckhlaWdodCAtIHRodW1iSGVpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4gKHRoaXMuc2xpZGVySW5pdGlhbGl6ZWRfID0gdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtQb2ludGVyRXZlbnR9IGV2ZW50IFRoZSBicm93c2VyIGV2ZW50IHRvIGhhbmRsZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUNvbnRhaW5lckNsaWNrXyhldmVudCkge1xuICAgIGNvbnN0IHZpZXcgPSB0aGlzLmdldE1hcCgpLmdldFZpZXcoKTtcblxuICAgIGNvbnN0IHJlbGF0aXZlUG9zaXRpb24gPSB0aGlzLmdldFJlbGF0aXZlUG9zaXRpb25fKFxuICAgICAgZXZlbnQub2Zmc2V0WCAtIHRoaXMudGh1bWJTaXplX1swXSAvIDIsXG4gICAgICBldmVudC5vZmZzZXRZIC0gdGhpcy50aHVtYlNpemVfWzFdIC8gMixcbiAgICApO1xuXG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMuZ2V0UmVzb2x1dGlvbkZvclBvc2l0aW9uXyhyZWxhdGl2ZVBvc2l0aW9uKTtcbiAgICBjb25zdCB6b29tID0gdmlldy5nZXRDb25zdHJhaW5lZFpvb20odmlldy5nZXRab29tRm9yUmVzb2x1dGlvbihyZXNvbHV0aW9uKSk7XG5cbiAgICB2aWV3LmFuaW1hdGVJbnRlcm5hbCh7XG4gICAgICB6b29tOiB6b29tLFxuICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb25fLFxuICAgICAgZWFzaW5nOiBlYXNlT3V0LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBkcmFnZ2VyIHN0YXJ0IGV2ZW50cy5cbiAgICogQHBhcmFtIHtQb2ludGVyRXZlbnR9IGV2ZW50IFRoZSBkcmFnIGV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlRHJhZ2dlclN0YXJ0XyhldmVudCkge1xuICAgIGlmICghdGhpcy5kcmFnZ2luZ18gJiYgZXZlbnQudGFyZ2V0ID09PSB0aGlzLmVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyAoXG4gICAgICAgIHRoaXMuZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZFxuICAgICAgKTtcbiAgICAgIHRoaXMuZ2V0TWFwKCkuZ2V0VmlldygpLmJlZ2luSW50ZXJhY3Rpb24oKTtcbiAgICAgIHRoaXMuc3RhcnRYXyA9IGV2ZW50LmNsaWVudFggLSBwYXJzZUZsb2F0KGVsZW1lbnQuc3R5bGUubGVmdCk7XG4gICAgICB0aGlzLnN0YXJ0WV8gPSBldmVudC5jbGllbnRZIC0gcGFyc2VGbG9hdChlbGVtZW50LnN0eWxlLnRvcCk7XG4gICAgICB0aGlzLmRyYWdnaW5nXyA9IHRydWU7XG5cbiAgICAgIGlmICh0aGlzLmRyYWdMaXN0ZW5lcktleXNfLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb25zdCBkcmFnID0gdGhpcy5oYW5kbGVEcmFnZ2VyRHJhZ187XG4gICAgICAgIGNvbnN0IGVuZCA9IHRoaXMuaGFuZGxlRHJhZ2dlckVuZF87XG4gICAgICAgIGNvbnN0IGRvYyA9IHRoaXMuZ2V0TWFwKCkuZ2V0T3duZXJEb2N1bWVudCgpO1xuICAgICAgICB0aGlzLmRyYWdMaXN0ZW5lcktleXNfLnB1c2goXG4gICAgICAgICAgbGlzdGVuKGRvYywgUG9pbnRlckV2ZW50VHlwZS5QT0lOVEVSTU9WRSwgZHJhZywgdGhpcyksXG4gICAgICAgICAgbGlzdGVuKGRvYywgUG9pbnRlckV2ZW50VHlwZS5QT0lOVEVSVVAsIGVuZCwgdGhpcyksXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBkcmFnZ2VyIGRyYWcgZXZlbnRzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gZXZlbnQgVGhlIGRyYWcgZXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVEcmFnZ2VyRHJhZ18oZXZlbnQpIHtcbiAgICBpZiAodGhpcy5kcmFnZ2luZ18pIHtcbiAgICAgIGNvbnN0IGRlbHRhWCA9IGV2ZW50LmNsaWVudFggLSB0aGlzLnN0YXJ0WF87XG4gICAgICBjb25zdCBkZWx0YVkgPSBldmVudC5jbGllbnRZIC0gdGhpcy5zdGFydFlfO1xuICAgICAgY29uc3QgcmVsYXRpdmVQb3NpdGlvbiA9IHRoaXMuZ2V0UmVsYXRpdmVQb3NpdGlvbl8oZGVsdGFYLCBkZWx0YVkpO1xuICAgICAgdGhpcy5jdXJyZW50UmVzb2x1dGlvbl8gPVxuICAgICAgICB0aGlzLmdldFJlc29sdXRpb25Gb3JQb3NpdGlvbl8ocmVsYXRpdmVQb3NpdGlvbik7XG4gICAgICB0aGlzLmdldE1hcCgpLmdldFZpZXcoKS5zZXRSZXNvbHV0aW9uKHRoaXMuY3VycmVudFJlc29sdXRpb25fKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGRyYWdnZXIgZW5kIGV2ZW50cy5cbiAgICogQHBhcmFtIHtQb2ludGVyRXZlbnR9IGV2ZW50IFRoZSBkcmFnIGV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlRHJhZ2dlckVuZF8oZXZlbnQpIHtcbiAgICBpZiAodGhpcy5kcmFnZ2luZ18pIHtcbiAgICAgIGNvbnN0IHZpZXcgPSB0aGlzLmdldE1hcCgpLmdldFZpZXcoKTtcbiAgICAgIHZpZXcuZW5kSW50ZXJhY3Rpb24oKTtcblxuICAgICAgdGhpcy5kcmFnZ2luZ18gPSBmYWxzZTtcbiAgICAgIHRoaXMuc3RhcnRYXyA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuc3RhcnRZXyA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZHJhZ0xpc3RlbmVyS2V5c18uZm9yRWFjaCh1bmxpc3RlbkJ5S2V5KTtcbiAgICAgIHRoaXMuZHJhZ0xpc3RlbmVyS2V5c18ubGVuZ3RoID0gMDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUG9zaXRpb25zIHRoZSB0aHVtYiBpbnNpZGUgaXRzIGNvbnRhaW5lciBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIHJlc29sdXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByZXMgVGhlIHJlcy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNldFRodW1iUG9zaXRpb25fKHJlcykge1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5nZXRQb3NpdGlvbkZvclJlc29sdXRpb25fKHJlcyk7XG4gICAgY29uc3QgdGh1bWIgPSAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyAodGhpcy5lbGVtZW50LmZpcnN0RWxlbWVudENoaWxkKTtcblxuICAgIGlmICh0aGlzLmRpcmVjdGlvbl8gPT0gRGlyZWN0aW9uLkhPUklaT05UQUwpIHtcbiAgICAgIHRodW1iLnN0eWxlLmxlZnQgPSB0aGlzLndpZHRoTGltaXRfICogcG9zaXRpb24gKyAncHgnO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHVtYi5zdHlsZS50b3AgPSB0aGlzLmhlaWdodExpbWl0XyAqIHBvc2l0aW9uICsgJ3B4JztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgcmVsYXRpdmUgcG9zaXRpb24gb2YgdGhlIHRodW1iIGdpdmVuIHggYW5kIHkgb2Zmc2V0cy4gIFRoZVxuICAgKiByZWxhdGl2ZSBwb3NpdGlvbiBzY2FsZXMgZnJvbSAwIHRvIDEuICBUaGUgeCBhbmQgeSBvZmZzZXRzIGFyZSBhc3N1bWVkIHRvIGJlXG4gICAqIGluIHBpeGVsIHVuaXRzIHdpdGhpbiB0aGUgZHJhZ2dlciBsaW1pdHMuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IFBpeGVsIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBsZWZ0IG9mIHRoZSBzbGlkZXIuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IFBpeGVsIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSB0b3Agb2YgdGhlIHNsaWRlci5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgcmVsYXRpdmUgcG9zaXRpb24gb2YgdGhlIHRodW1iLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0UmVsYXRpdmVQb3NpdGlvbl8oeCwgeSkge1xuICAgIGxldCBhbW91bnQ7XG4gICAgaWYgKHRoaXMuZGlyZWN0aW9uXyA9PT0gRGlyZWN0aW9uLkhPUklaT05UQUwpIHtcbiAgICAgIGFtb3VudCA9IHggLyB0aGlzLndpZHRoTGltaXRfO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbW91bnQgPSB5IC8gdGhpcy5oZWlnaHRMaW1pdF87XG4gICAgfVxuICAgIHJldHVybiBjbGFtcChhbW91bnQsIDAsIDEpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIGNvcnJlc3BvbmRpbmcgcmVzb2x1dGlvbiBvZiB0aGUgdGh1bWIgZ2l2ZW4gaXRzIHJlbGF0aXZlXG4gICAqIHBvc2l0aW9uICh3aGVyZSAwIGlzIHRoZSBtaW5pbXVtIGFuZCAxIGlzIHRoZSBtYXhpbXVtKS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uIFRoZSByZWxhdGl2ZSBwb3NpdGlvbiBvZiB0aGUgdGh1bWIuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGNvcnJlc3BvbmRpbmcgcmVzb2x1dGlvbi5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldFJlc29sdXRpb25Gb3JQb3NpdGlvbl8ocG9zaXRpb24pIHtcbiAgICBjb25zdCBmbiA9IHRoaXMuZ2V0TWFwKCkuZ2V0VmlldygpLmdldFJlc29sdXRpb25Gb3JWYWx1ZUZ1bmN0aW9uKCk7XG4gICAgcmV0dXJuIGZuKDEgLSBwb3NpdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB0aGUgcmVsYXRpdmUgcG9zaXRpb24gb2YgdGhlIHNsaWRlciBmb3IgdGhlIGdpdmVuIHJlc29sdXRpb24uICBBXG4gICAqIHJlbGF0aXZlIHBvc2l0aW9uIG9mIDAgY29ycmVzcG9uZHMgdG8gdGhlIG1pbmltdW0gdmlldyByZXNvbHV0aW9uLiAgQVxuICAgKiByZWxhdGl2ZSBwb3NpdGlvbiBvZiAxIGNvcnJlc3BvbmRzIHRvIHRoZSBtYXhpbXVtIHZpZXcgcmVzb2x1dGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHJlcyBUaGUgcmVzb2x1dGlvbi5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgcmVsYXRpdmUgcG9zaXRpb24gdmFsdWUgKGJldHdlZW4gMCBhbmQgMSkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRQb3NpdGlvbkZvclJlc29sdXRpb25fKHJlcykge1xuICAgIGNvbnN0IGZuID0gdGhpcy5nZXRNYXAoKS5nZXRWaWV3KCkuZ2V0VmFsdWVGb3JSZXNvbHV0aW9uRnVuY3Rpb24oKTtcbiAgICByZXR1cm4gY2xhbXAoMSAtIGZuKHJlcyksIDAsIDEpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgem9vbXNsaWRlciBlbGVtZW50LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEV2ZW50IE1hcCBldmVudC5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICByZW5kZXIobWFwRXZlbnQpIHtcbiAgICBpZiAoIW1hcEV2ZW50LmZyYW1lU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnNsaWRlckluaXRpYWxpemVkXyAmJiAhdGhpcy5pbml0U2xpZGVyXygpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IG1hcEV2ZW50LmZyYW1lU3RhdGUudmlld1N0YXRlLnJlc29sdXRpb247XG4gICAgdGhpcy5jdXJyZW50UmVzb2x1dGlvbl8gPSByZXM7XG4gICAgdGhpcy5zZXRUaHVtYlBvc2l0aW9uXyhyZXMpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFpvb21TbGlkZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ol/control/ZoomSlider.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ol/control/ZoomToExtent.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/control/ZoomToExtent.js ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Control_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Control.js */ \"(app-pages-browser)/./node_modules/ol/control/Control.js\");\n/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/EventType.js */ \"(app-pages-browser)/./node_modules/ol/events/EventType.js\");\n/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../css.js */ \"(app-pages-browser)/./node_modules/ol/css.js\");\n/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ \"(app-pages-browser)/./node_modules/ol/proj.js\");\n/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../geom/Polygon.js */ \"(app-pages-browser)/./node_modules/ol/geom/Polygon.js\");\n/**\n * @module ol/control/ZoomToExtent\n */\n\n\n\n\n\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-zoom-extent'] Class name.\n * @property {HTMLElement|string} [target] Specify a target if you want the control\n * to be rendered outside of the map's viewport.\n * @property {string|HTMLElement} [label='E'] Text label to use for the button.\n * Instead of text, also an element (e.g. a `span` element) can be used.\n * @property {string} [tipLabel='Fit to extent'] Text label to use for the button tip.\n * @property {import(\"../extent.js\").Extent} [extent] The extent to zoom to. If undefined the validity\n * extent of the view projection is used.\n */\n\n/**\n * @classdesc\n * A button control which, when pressed, changes the map view to a specific\n * extent. To style this control use the css selector `.ol-zoom-extent`.\n *\n * @api\n */\nclass ZoomToExtent extends _Control_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super({\n      element: document.createElement('div'),\n      target: options.target,\n    });\n\n    /**\n     * @type {?import(\"../extent.js\").Extent|null}\n     * @protected\n     */\n    this.extent = options.extent ? options.extent : null;\n\n    const className =\n      options.className !== undefined ? options.className : 'ol-zoom-extent';\n\n    const label = options.label !== undefined ? options.label : 'E';\n    const tipLabel =\n      options.tipLabel !== undefined ? options.tipLabel : 'Fit to extent';\n    const button = document.createElement('button');\n    button.setAttribute('type', 'button');\n    button.title = tipLabel;\n    button.appendChild(\n      typeof label === 'string' ? document.createTextNode(label) : label,\n    );\n\n    button.addEventListener(\n      _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].CLICK,\n      this.handleClick_.bind(this),\n      false,\n    );\n\n    const cssClasses =\n      className + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_3__.CLASS_UNSELECTABLE + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_3__.CLASS_CONTROL;\n    const element = this.element;\n    element.className = cssClasses;\n    element.appendChild(button);\n  }\n\n  /**\n   * @param {MouseEvent} event The event to handle\n   * @private\n   */\n  handleClick_(event) {\n    event.preventDefault();\n    this.handleZoomToExtent();\n  }\n\n  /**\n   * @protected\n   */\n  handleZoomToExtent() {\n    const map = this.getMap();\n    const view = map.getView();\n    const extent = !this.extent\n      ? view.getProjection().getExtent()\n      : (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserExtent)(this.extent, view.getProjection());\n    view.fitInternal((0,_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_4__.fromExtent)(extent));\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (ZoomToExtent);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vbC9jb250cm9sL1pvb21Ub0V4dGVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDbUM7QUFDWTtBQUNhO0FBQ2xCO0FBQ3lCOztBQUVuRTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEIsY0FBYyxvQkFBb0I7QUFDbEM7QUFDQSxjQUFjLG9CQUFvQjtBQUNsQztBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLCtCQUErQjtBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1EQUFPO0FBQ2xDO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sNERBQVM7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsdURBQWtCLFNBQVMsa0RBQWE7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHdEQUFjO0FBQ3RCLHFCQUFxQiw0REFBaUI7QUFDdEM7QUFDQTs7QUFFQSwrREFBZSxZQUFZLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL29sL2NvbnRyb2wvWm9vbVRvRXh0ZW50LmpzPzQxZDQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIG9sL2NvbnRyb2wvWm9vbVRvRXh0ZW50XG4gKi9cbmltcG9ydCBDb250cm9sIGZyb20gJy4vQ29udHJvbC5qcyc7XG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4uL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuaW1wb3J0IHtDTEFTU19DT05UUk9MLCBDTEFTU19VTlNFTEVDVEFCTEV9IGZyb20gJy4uL2Nzcy5qcyc7XG5pbXBvcnQge2Zyb21Vc2VyRXh0ZW50fSBmcm9tICcuLi9wcm9qLmpzJztcbmltcG9ydCB7ZnJvbUV4dGVudCBhcyBwb2x5Z29uRnJvbUV4dGVudH0gZnJvbSAnLi4vZ2VvbS9Qb2x5Z29uLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzTmFtZT0nb2wtem9vbS1leHRlbnQnXSBDbGFzcyBuYW1lLlxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudHxzdHJpbmd9IFt0YXJnZXRdIFNwZWNpZnkgYSB0YXJnZXQgaWYgeW91IHdhbnQgdGhlIGNvbnRyb2xcbiAqIHRvIGJlIHJlbmRlcmVkIG91dHNpZGUgb2YgdGhlIG1hcCdzIHZpZXdwb3J0LlxuICogQHByb3BlcnR5IHtzdHJpbmd8SFRNTEVsZW1lbnR9IFtsYWJlbD0nRSddIFRleHQgbGFiZWwgdG8gdXNlIGZvciB0aGUgYnV0dG9uLlxuICogSW5zdGVhZCBvZiB0ZXh0LCBhbHNvIGFuIGVsZW1lbnQgKGUuZy4gYSBgc3BhbmAgZWxlbWVudCkgY2FuIGJlIHVzZWQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3RpcExhYmVsPSdGaXQgdG8gZXh0ZW50J10gVGV4dCBsYWJlbCB0byB1c2UgZm9yIHRoZSBidXR0b24gdGlwLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBbZXh0ZW50XSBUaGUgZXh0ZW50IHRvIHpvb20gdG8uIElmIHVuZGVmaW5lZCB0aGUgdmFsaWRpdHlcbiAqIGV4dGVudCBvZiB0aGUgdmlldyBwcm9qZWN0aW9uIGlzIHVzZWQuXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBIGJ1dHRvbiBjb250cm9sIHdoaWNoLCB3aGVuIHByZXNzZWQsIGNoYW5nZXMgdGhlIG1hcCB2aWV3IHRvIGEgc3BlY2lmaWNcbiAqIGV4dGVudC4gVG8gc3R5bGUgdGhpcyBjb250cm9sIHVzZSB0aGUgY3NzIHNlbGVjdG9yIGAub2wtem9vbS1leHRlbnRgLlxuICpcbiAqIEBhcGlcbiAqL1xuY2xhc3MgWm9vbVRvRXh0ZW50IGV4dGVuZHMgQ29udHJvbCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zID8gb3B0aW9ucyA6IHt9O1xuXG4gICAgc3VwZXIoe1xuICAgICAgZWxlbWVudDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgICB0YXJnZXQ6IG9wdGlvbnMudGFyZ2V0LFxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgez9pbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fG51bGx9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHRoaXMuZXh0ZW50ID0gb3B0aW9ucy5leHRlbnQgPyBvcHRpb25zLmV4dGVudCA6IG51bGw7XG5cbiAgICBjb25zdCBjbGFzc05hbWUgPVxuICAgICAgb3B0aW9ucy5jbGFzc05hbWUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY2xhc3NOYW1lIDogJ29sLXpvb20tZXh0ZW50JztcblxuICAgIGNvbnN0IGxhYmVsID0gb3B0aW9ucy5sYWJlbCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5sYWJlbCA6ICdFJztcbiAgICBjb25zdCB0aXBMYWJlbCA9XG4gICAgICBvcHRpb25zLnRpcExhYmVsICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnRpcExhYmVsIDogJ0ZpdCB0byBleHRlbnQnO1xuICAgIGNvbnN0IGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnYnV0dG9uJyk7XG4gICAgYnV0dG9uLnRpdGxlID0gdGlwTGFiZWw7XG4gICAgYnV0dG9uLmFwcGVuZENoaWxkKFxuICAgICAgdHlwZW9mIGxhYmVsID09PSAnc3RyaW5nJyA/IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxhYmVsKSA6IGxhYmVsLFxuICAgICk7XG5cbiAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIEV2ZW50VHlwZS5DTElDSyxcbiAgICAgIHRoaXMuaGFuZGxlQ2xpY2tfLmJpbmQodGhpcyksXG4gICAgICBmYWxzZSxcbiAgICApO1xuXG4gICAgY29uc3QgY3NzQ2xhc3NlcyA9XG4gICAgICBjbGFzc05hbWUgKyAnICcgKyBDTEFTU19VTlNFTEVDVEFCTEUgKyAnICcgKyBDTEFTU19DT05UUk9MO1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgZWxlbWVudC5jbGFzc05hbWUgPSBjc3NDbGFzc2VzO1xuICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50IFRoZSBldmVudCB0byBoYW5kbGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUNsaWNrXyhldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy5oYW5kbGVab29tVG9FeHRlbnQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBoYW5kbGVab29tVG9FeHRlbnQoKSB7XG4gICAgY29uc3QgbWFwID0gdGhpcy5nZXRNYXAoKTtcbiAgICBjb25zdCB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICBjb25zdCBleHRlbnQgPSAhdGhpcy5leHRlbnRcbiAgICAgID8gdmlldy5nZXRQcm9qZWN0aW9uKCkuZ2V0RXh0ZW50KClcbiAgICAgIDogZnJvbVVzZXJFeHRlbnQodGhpcy5leHRlbnQsIHZpZXcuZ2V0UHJvamVjdGlvbigpKTtcbiAgICB2aWV3LmZpdEludGVybmFsKHBvbHlnb25Gcm9tRXh0ZW50KGV4dGVudCkpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFpvb21Ub0V4dGVudDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ol/control/ZoomToExtent.js\n"));

/***/ })

}]);